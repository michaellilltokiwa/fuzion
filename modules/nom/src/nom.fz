# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion nom module feature nom, a parser combinator framework
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# Port of https://github.com/Geal/nom/ by Geoffroy Couprie

# nom is a parser combinator framework
# for more information go to:
# https://github.com/Geal/nom/
nom is

  # a parser takes an input of type I
  # and produces either an error
  # or a result of type O and a rest of type R
  parser(I, R, O type, parse I -> parse_result R O) is
    map(OM type, mapper O -> outcome OM) parser I R OM is
      parser I R OM (i ->
        match parse i
          s success =>
            match mapper s.out
              o OM => success s.rest o
              e2 error => e2
          e1 error => e1
        )

  # the result of parsing, if successful
  success(R, O type, rest R, out O) is
    redef as_string => $out


  # the result of parser.parse
  parse_result(I, O type) : choice (success I O) error is
    redef as_string =>
      match parse_result.this
        s success => $s
        e error => $e



  # choice combinators
  branch is

    # return result of first succeeding parser
    alt(I, R, O type, p array (parser I R O)) parser I R O is
      parser I R O (input ->
        p
          .mapSequence (p -> p.parse input)
          .filter (r -> match r
                          success => true
                          error => false)
          .first (error "alt: no parser successful")
      )


  # string parsers
  string_parsers is

    # matches the of str
    tag(str String) parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint)
    is
      parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (input ->
        if (String.type.from_codepoint_sequence input).starts_with str
          success (input.drop str.codepoint_length).as_seq str.as_codepoint_sequence
        else
          error "tag ($str) not found"
      )

    # match zero or more whitespace
    whitespace0 parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
      parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (input ->
        ws := input.take_while (x -> x.is_blank)
        success (input.drop ws.count).as_seq ws.as_seq
      )

    # match one or more digit
    digit1 parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
      sequence.take_while1 codepoint (c -> codepoint.type.ascii_digit.contains c.val)

    # convert a parser taking a sequence of codepoints to a parser that takes a string
    to_string_input(R, O type, p parser (Sequence codepoint) R O) parser String R O is
      combinator.map_inp (Sequence codepoint) String R O p (str -> str.as_codepoint_sequence)

    # convert a parser returning a sequence of codepoints to a parser that returns a string
    to_string_output(I, R type, p parser I R (Sequence codepoint)) parser I R String is
      p.map String (seq -> String.type.from_codepoint_sequence seq)

    # convert a parser taking and returning to codepoints to a parser taking and returning a string
    to_string_parser(R type, p parser (Sequence codepoint) R (Sequence codepoint)) parser String R String is
      to_string_output (to_string_input p)



  # parser working on sequences of input
  sequence is

    # take while cond is satisfied
    take_while0(T type, cond T -> bool) parser (Sequence T) (Sequence T) (Sequence T) is
      parser (Sequence T) (Sequence T) (Sequence T) (input ->
        rest Sequence T := input.drop_while cond
        matched Sequence T := input.take_while cond
        success rest matched
        )

    # take while cond is satisfied, at least once
    take_while1(T type, cond T -> bool) parser (Sequence T) (Sequence T) (Sequence T) is
      parser (Sequence T) (Sequence T) (Sequence T) (input ->
        matched Sequence T := input.take_while cond
        if matched.is_empty
          error "expected at least one match in: $input"
        else
          rest Sequence T := input.drop_while cond
          success rest matched
        )

    # matches input as often as possible but at least m times and at most n times.
    take_while_m_n(T type, m, n i32, cond (T) -> bool) parser (Sequence T) (Sequence T) (Sequence T) is
      parser (Sequence T) (Sequence T) (Sequence T) (input ->
        if input.is_empty
          error "input is empty"
        else
          taken := input
            .take n
            .take_while (x -> cond x)
          if taken.count < m
            error "not enough codepoints matched, expected $m or more, got {taken.count}"
          else
            success (input.drop taken.count).as_seq taken.as_seq
      )

    # return result of p1 and p2 as tuple, drop result of p_sep
    separated_pair(I type, R1, R2, R3, O1, O2, O3 type, p1 parser I R1 O1, p_sep parser R1 R2 O2, p2 () -> (parser R2 R3 O3)) parser I R3 (tuple O1 O3) is
      parser I R3 (tuple O1 O3) (input ->
        match p1.parse input
          s1 success =>
            match p_sep.parse s1.rest
              s2 success =>
                match p2().parse s2.rest
                  s3 success => success s3.rest (s1.out, s3.out)
                  e3 error => e3
              e2 error => e2
          e1 error => e1
        )


  # parsers applied multiple times
  multi is

    # apply parser multiple times, return results as sequence
    many0 (I, O type, p parser I I O) parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p.parse input
          s1 success I O =>
            match (parse s1.rest)
              s2 success I (Sequence O) => success s2.rest ([s1.out]++s2.out).as_seq
              error => panic "invalid state, many0 must always succeed."
          # NYI type inference should infer correct type of empty array
          error => success input (lists.empty O).as_seq
      parser I I (Sequence O) (input -> parse input)

    # apply parser at least once, return results as sequence
    many1 (I, O type, p parser I I O) parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p.parse input
          s1 success I O => (many0 p).parse input
          e error => e
      parser I I (Sequence O) (input -> parse input)

    # parse a separated list of values, zero or more values
    separated_list0(I, O, D type, p_sep parser I I D, p_value parser I I O) parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p_value.parse input
          s1 success =>
            match (many0 (combinator.preceded p_sep p_value)).parse s1.rest
              s2 success => success s2.rest ([s1.out]++s2.out).as_seq
              e error => panic "invalid state, many always succeeds"
          # NYI type inference should infer correct type of empty array
          error => success input (lists.empty O).as_seq
      parser I I (Sequence O) (input -> parse input)

    # parse a separated list of values, one or more values
    separated_list1(I, O, D type, p_sep parser I I D, p_value () -> (parser I I O)) parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p_value().parse input
          s1 success =>
            match (many0 (combinator.preceded p_sep p_value())).parse s1.rest
              s2 success => success s2.rest ([s1.out]++s2.out).as_seq
              error => panic "invalid state, many always succeeds"
          e error => e
      parser I I (Sequence O) (input -> parse input)



  # general purpose combinators
  combinator is

    # apply p1 then p2 and return their results as a tuple.
    tuple2(I, O1, O2 type, p1 parser I I O1, p2 parser I I O2) parser I I (tuple O1 O2) is
      parse(input I) parse_result I (tuple O1 O2) is
        match p1.parse(input)
          s1 success I O1 =>
            match p2.parse s1.rest
              s2 success I O2 =>
                success s2.rest (s1.out, s2.out)
              e2 error => e2
          e1 error => e1
      parser I I (tuple O1 O2) (input -> parse input)

    # apply p1 then p2 then p3 and return their results as a tuple.
    tuple3(I, O1, O2, O3 type, p1 parser I I O1, p2 parser I I O2, p3 parser I I O3) parser I I (tuple O1 O2 O3) is
      parse(input I) parse_result I (tuple O1 O2 O3) is
        match p1.parse(input)
          s1 success I O1 =>
            match p2.parse s1.rest
              s2 success I O2 =>
                match p3.parse s2.rest
                  s3 success I O3 => success s3.rest (s1.out, s2.out, s3.out)
                  e3 error => e3
              e2 error => e2
          e1 error => e1
      parser I I (tuple O1 O2 O3) (input -> parse input)

    # discard the output of the first parser, return the result of the second parser
    preceded(I, O1, O2 type, p1 parser I I O1, p2 parser I I O2) parser I I O2 is
      parse(input I) parse_result I O2 is
        match p1.parse input
          s1 success I O1 =>
            p2.parse s1.rest
          e1 error => e1
      parser I I O2 (input -> parse input)

    # discard p1 and p3, return result of p2
    delimited(I, O1, O2, O3 type, p1 parser I I O1, p2 parser I I O2, p3 parser I I O3) parser I I O2 is
      parse(input I) parse_result I O2 is
        match p1.parse(input)
          s1 success I O1 =>
            match p2.parse s1.rest
              s2 success I O2 =>
                match p3.parse s2.rest
                  s3 success I O3 => success s3.rest s2.out
                  e3 error => e3
              e2 error => e2
          e1 error => e1
      parser I I O2 (input -> parse input)

    # map input to parser p
    map_inp(I1, I2, R, O type, p parser I1 R O, mapper1 I2 -> I1) parser I2 R O is
      parse(input I2) parse_result R O is
        p.parse (mapper1 input)
      parser I2 R O (input -> parse input)



  parsers : combinator, string_parsers, sequence, branch, multi is

    json_value : choice String i64 f64 bool nil (Sequence json_value) (Map String json_value) is
      redef as_string String is
        match json_value.this
          s String => "\"$s\""
          i i64 => $i
          f f64 => $f
          b bool => $b
          n nil => "null"
          seq Sequence => $seq
          m (Map String json_value) => "\{$m}"

    json =>

      # parser for a json string
      parser_string =>

        is_hex_digit(c codepoint) bool is
          codepoint.type.ascii_digit.contains c.val
            || (u32 0x41 .. 0x46).contains c.val

        parser_hex_unicode =>
          preceded (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (tag "\\") (take_while_m_n codepoint 4 4 ((c) -> is_hex_digit c))
            .map (Sequence codepoint) (d ->
              (c,_) := d.reduce (u32 0, u32 4) (r, c -> (val, exp) := r; (c.parse_u32_hex.val * 10**exp, exp-1))
              [(codepoint c)])

        parse_and_map(t, r String) parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
          (tag t).map (Sequence codepoint) (_ -> r.as_codepoint_sequence)

        parser_escapings :=
          alt [
            (parse_and_map "\\\"" "\""),
            (parse_and_map "\\\\" "\\"),
            (parse_and_map "\\/" "/"),
            (parse_and_map "\\b" "\b"),
            (parse_and_map "\\f" "\f"),
            (parse_and_map "\\n" "\n"),
            (parse_and_map "\\r" "\r"),
            (parse_and_map "\\t" "\t"),
            parser_hex_unicode
            ]

        parser_regular_codepoint parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) :=
          (take_while1 codepoint (c-> (c != "\"") & (c != "\\")))


        p parser (Sequence codepoint) (Sequence codepoint) (Sequence (Sequence codepoint)) := many0 (alt [parser_regular_codepoint, parser_escapings])

        delimited (tag "\"") p (tag "\"")
          .map String (x -> String.type.join (x.mapSequence String (y -> String.type.from_codepoint_sequence y)) "")


      # parser for a json number
      # NYI fraction, negative numbers, exponents
      parser_number =>

        parser_digit_1_9 := take_while0 codepoint (c -> (u32 0x31 .. 0x39).contains c.val)
        parser_digit := take_while0 codepoint (c -> codepoint.type.ascii_digit.contains c.val)

        parser_fraction :=
          (preceded (tag ".") (many1 parser_digit)).map u64 (x -> (String.type.from_codepoint_sequence (x.flatMapSequence codepoint (y -> y))).parse_u64.val)

        # parser_exponent := preceded (alt [tag "e", tag "E"]) parser_signed_digit

        (take_while1 codepoint (c -> codepoint.type.ascii_digit.contains c.val)).map json_value (x -> (String.type.from_codepoint_sequence x).parse_i64.val)

      # parser for true
      parser_true :=
        (tag "true").map json_value (x -> true)

      # parser for false
      parser_false :=
        (tag "false").map json_value (x -> false)

      # parser for null
      parser_null :=
        (tag "null").map json_value (x -> nil)

      # parser for json array
      parser_array =>
        parser_no_values parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=
          whitespace0.map (Sequence json_value) (x -> lists.empty json_value)

        parser_comma_sep_value parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=
          separated_list1 (Sequence codepoint) json_value (Sequence codepoint) (tag ",") ()->parser_json_value_delimited

        tmp parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=  delimited (tag "[") (alt [parser_comma_sep_value, parser_no_values]) (tag "]")
        tmp.map json_value (x->x)

      # parser for json object
      parser_object =>
        parser_key_value parser (Sequence codepoint) (Sequence codepoint) (tuple String json_value) is
          separated_pair (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) String (Sequence codepoint) json_value (delimited whitespace0 parser_string whitespace0) (tag ":") ()->parser_json_value_delimited

        parser_no_key_values parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple String json_value)) is
          whitespace0.map (Sequence (tuple String json_value)) (x -> lists.empty (tuple String json_value))

        parser_key_values parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple String json_value)) is
          separated_list1 (Sequence codepoint) (tuple String json_value) (Sequence codepoint) (tag ",") ()->parser_key_value

        delimited (tag "\{") (alt [parser_key_values, parser_no_key_values]) (tag "}")
          .map json_value (x -> map_of x.as_array)

      # parser for a json_value: true, false, [], {}, numbers, strings etc.
      parser_json_value =>
        alt (Sequence codepoint) (Sequence codepoint) json_value [
          parser_string.map json_value (x->x),
          parser_number,
          parser_object,
          parser_array,
          parser_true,
          parser_false,
          parser_null]

      # parser for json_value which may be surrounded by whitespace
      parser_json_value_delimited parser (Sequence codepoint) (Sequence codepoint) json_value is
        delimited (Sequence codepoint) (Sequence codepoint) json_value (Sequence codepoint) whitespace0 parser_json_value whitespace0


      # map parser to take string input
      to_string_input parser_json_value_delimited
