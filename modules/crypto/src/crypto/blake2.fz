# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion feature crypto.blake2s
#
# -----------------------------------------------------------------------


# port of https:#github.com/ziglang/zig/blob/master/lib/std/crypto/blake2.zig
blake2s(out_bits u32)
  pre out_bits = 128 || out_bits = 160 || out_bits = 224 || out_bits = 256
is

  type.blake2s128 => crypto.blake2s 128
  type.blake2s160 => crypto.blake2s 160
  type.blake2s224 => crypto.blake2s 224
  type.blake2s256 => crypto.blake2s 256


  digest_length := out_bits / 8

  initial_value array u32 => [
      0x6A09E667,
      0xBB67AE85,
      0x3C6EF372,
      0xA54FF53A,
      0x510E527F,
      0x9B05688C,
      0x1F83D9AB,
      0x5BE0CD19
  ]

  sigma array (array u8) => [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],
    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ],
    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 ],
    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 ],
    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 ],
    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 ],
    [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 ],
    [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 ],
    [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 ],
    [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 ]
  ]

  public hash(b array u8, key, salt option (array u8)) array u8 =>

    lm : mutate is

    lm ()->
      h := iv.as_mutable lm

    key_len = if (options.key) |key| key.len else 0
    # default parameters
    h[0] ^= 0x01010000 ^ @as(u32, @truncate(key_len << 8)) ^ @as(u32, @intCast(options.expected_out_bits >> 3))
    t = 0
    buf_len = 0

    if (options.salt) |salt| =>
        h[4] ^= mem.readInt(u32, salt[0..4], .little)
        h[5] ^= mem.readInt(u32, salt[4..8], .little)

    if (options.context) |context| =>
        h[6] ^= mem.readInt(u32, context[0..4], .little)
        h[7] ^= mem.readInt(u32, context[4..8], .little)

    if (key_len > 0) =>
        @memset(buf[key_len..], 0)
        update(options.key.?)
        buf_len = 64

    update b
    final


  update(d: *Self, b: []const u8) void =>
    off: usize = 0

    # Partial buffer exists from previous update. Copy into buffer then hash.
    if (buf_len != 0 and buf_len + b.len > 64) =>
        off += 64 - buf_len
        @memcpy(buf[buf_len..][0..off], b[0..off])
        t += 64
        round(buf[0..], false)
        buf_len = 0


    # Full middle blocks.
    while (off + 64 < b.len) : (off += 64) =>
        t += 64
        round(b[off..][0..64], false)


    # Copy any remainder for next pass.
    const b_slice = b[off..]
    @memcpy(buf[buf_len..][0..b_slice.len], b_slice)
    buf_len += @as(u8, @intCast(b_slice.len))


  final array u8 =>
    @memset(buf[buf_len..], 0)
    t += buf_len
    round(buf[0..], true)
    for (&h) |*x| x.* = mem.nativeToLittle(u32, x.*)
    out.* = @as(*[digest_length]u8, @ptrCast(&h)).*


  round(d: *Self, b: *const [64]u8, last: bool) void =>
    m: [16]u32 = undefined
    v: [16]u32 = undefined

    for (&m, 0..) |*r, i| =>
        r.* = mem.readInt(u32, b[4 * i ..][0..4], .little)


    k: usize = 0
    while (k < 8) : (k += 1) =>
      v[k] = h[k]
      v[k + 8] = iv[k]


    v[12] ^= @as(u32, @truncate(t))
    v[13] ^= @as(u32, @intCast(t >> 32))
    if (last) v[14] = ~v[14]

    rounds :=
        [(0, 4, 8, 12, 0, 1),
         (1, 5, 9, 13, 2, 3),
         (2, 6, 10, 14, 4, 5),
         (3, 7, 11, 15, 6, 7),
         (0, 5, 10, 15, 8, 9),
         (1, 6, 11, 12, 10, 11),
         (2, 7, 8, 13, 12, 13),
         (3, 4, 9, 14, 14, 15)]


    for j:=0, j+1
    while j < 10 do
      for r in rounds do
        v[r.0] := v[r.0] +% v[r.1] +% m[sigma[j][r.x]]
        v[r.3] := math.rotr(u32, v[r.3] ^ v[r.0], @as(usize, 16))
        v[r.2] := v[r.2] +% v[r.3]
        v[r.1] := math.rotr(u32, v[r.1] ^ v[r.2], @as(usize, 12))
        v[r.0] := v[r.0] +% v[r.1] +% m[sigma[j][r.y]]
        v[r.3] := math.rotr(u32, v[r.3] ^ v[r.0], @as(usize, 8))
        v[r.2] := v[r.2] +% v[r.3]
        v[r.1] := math.rotr(u32, v[r.1] ^ v[r.2], @as(usize, 7))



    for (&h, 0..) |*r, i| =>
      r.* ^= v[i] ^ v[i + 8]


