# <http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF>

Qtest is
  r := [
    2.0**12.0 + 2.0,            # for 24 sig. bits,
    2.0**12.0 + 2.25,           # and 6 hex
    16.0**3.0 + 1.0 + 1.0/16.0**2.0,    # 6 hex. IBM
    2.0**24.0 + 2.0,            # 48 bits CRAY -
    2.0**24.0 + 2.25,           # rounded
    2.0**24.0 + 3.0,            # 48 bits chopped
    94906267.0,                 # 53 sig. bits.
    94906267.0 + 0.25,            # 53 sig. bits.
    2.0**28.0 - 5.5,             # PowerPC, i860
    2.0**28.0 - 4.5,             # PowerPC, i860
    2.0**28.0 + 2.0,             # 56 sig. bits,
    2.0**28.0 + 2.25,            # and 14 hex.
    16.0**7.0 + 1 + 1.0/16.0**6.0,   # 14 hex. IBM
    2.0**32.0 + 2.0,             # 64 sig. bits.
    2.0**32.0 + 2.25,            # 64 sig. bits.
    ]

  abs(x f64) =>
    if x < 0
      -x
    else
      x

  log2(x f64) =>
    f64s.log(abs(x)) / f64s.log(2.0)

  min(x1, x2 f64) =>
    if x1 < x2
      x1
    else
      x2

  signum(f f64) =>
    s := f.castTo_u64 >> 63
    s

  copy_sign(x, y f64) =>
    #NYI NaN
    if signum x == signum y
      y
    else
      -y

  qdrtc( p, q, r f64) =>
    s := f64s.sqrt( q*q - p*r )
    S := q + copy_sign(s, q)
    if S == 0 then
      (r/p, r/p)
    else
      (r/S, S/p)

  qtrial(r f64) =>
    p := r-2.0
    q := r-1.0
    qdrt := qdrtc( p, q, r)
    x1 := qdrt.values.0
    x2 := qdrt.values.1
    e1 := -log2( x1 - 1.0 )
    e2 := -log2( (x2 - 1.0) - 2.0/p )
    min(e1, e2)

  e := f64s.positiveInfinity
  for j in (1..r.length) do
    t := qtrial(r[j-1])
    if (t < e || !(t == t)) then
      say  " Worst accuracy is $t sig. bits"
