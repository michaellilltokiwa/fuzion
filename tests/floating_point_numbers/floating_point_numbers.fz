# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test FloatingPointNumbers
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

floating_point_numbers is

  exitCode := 0

  chck(b bool, msg string) =>
    s := if b
      "PASSED: "
    else
      set exitCode := 1
      "FAILED: "
    say (s + msg)

  duplicate<T:float<T>>(f T) =>
    f + f

  threefold<T:float<T>>(f T) =>
    f + f + f

  generic_tests<T: float<T>>(a T) is
    # serialize floating point numbers
    chck ("{a.quietNaN}" ==  "nan")                                 "{a.name}: quiet nan serializes correctly"
    chck ("{a.negativeInfinity}" ==  "-inf")                        "{a.name}: neg inf serializes correctly"
    chck ("{a.positiveInfinity}" ==  "inf")                         "{a.name}: pos inf serializes correctly"
    chck ("{a.zero}" == "0")                                        "{a.name}: 0 serializes to string"
    chck ("{a.one}" == "1")                                         "{a.name}: 1 serializes to string"
    chck ("{a.one / (duplicate a.one)}" == "0.5")                   "{a.name}: 0.5 serializes to string"
    chck ("{a.one / (threefold a.one)}".startsWith "0.3333333")     "{a.name}: 1/3 serializes to string"

    # comparision operators
    chck (
      a.zero == a.zero &&
      a.zero != a.one &&
      a.one  >= a.zero &&
      a.zero <= a.one &&
      a.zero == a.zero &&
      a.one  >  a.zero &&
      a.zero <  a.one)                                              "{a.name}: comparison operators work as expected"

    # negation operator
    chck ((-(-a.zero) == a.zero) &&
          (-(-a.one) == a.one) &&
          (-(-a.positiveInfinity) == a.positiveInfinity) &&
          (-(-a.negativeInfinity) == a.negativeInfinity))          "{a.name}: double negation is same number"

    # operator +,-,*,/ test
    chck (a.zero + a.one == a.one)                                 "{a.name}: plus operator"
    chck (a.zero - a.one == -a.one)                                "{a.name}: minus operator"
    chck (a.zero * a.one == a.zero)                                "{a.name}: product operator"
    chck (a.zero / a.one == a.zero)                                "{a.name}: division operator"

    # sqrt
    two := a.one + a.one
    chck (a.sqrt (two * two) - two < a.epsilon)                    "{a.name}: sqrt"

    # exponentation / logarithm
    chck (a.exp(a.zero)  == a.one)                                 "{a.name}: exp"
    chck (a.log(a.one)   == a.zero)                                "{a.name}: log"

    # trigonometric
    chck (a.sin(a.zero)  == a.zero)                                "{a.name}: sin"
    chck (a.cos(a.zero)  == a.one)                                 "{a.name}: cos"
    chck (a.tan(a.zero)  == a.zero)                                "{a.name}: tan"
    chck (a.asin(a.zero) == a.zero)                                "{a.name}: asin"
    chck (a.acos(a.one)  == a.zero)                                "{a.name}: acos"
    chck (a.atan(a.zero) == a.zero)                                "{a.name}: atan"

    # hyperbolicus
    chck (a.sinh(a.zero)  == a.zero)                               "{a.name}: sinh"
    chck (a.cosh(a.zero)  == a.one)                                "{a.name}: cosh"
    chck (a.tanh(a.zero)  == a.zero)                               "{a.name}: tanh"
    chck (a.asinh(a.zero) == a.zero)                               "{a.name}: asinh"
    chck (a.acosh(a.one)  == a.zero)                               "{a.name}: acosh"
    chck (a.atanh(a.zero) == a.zero)                               "{a.name}: atanh"

  generic_tests f32s.zero
  generic_tests f64s.zero

  # power
  chck (f32 10.0 ** f32 2.0 == f32 100.0)                         "f32: 10 to the power 2 equals 100"
  chck (10.0 ** 2.0 == 100.0)                                     "f64: 10 to the power 2 equals 100"

  # modulo
  chck (f32 10.0 % f32 2.4 - f32 0.4 < f32 10.0 * f32s.epsilon)   "f32: 10 mod 2.4 is ~0.4"
  chck (10.0 % 2.4 - 0.4 <=10.0 * f64s.epsilon)                   "f64: 10 mod 2.4 is ~0.4"

  # castTo_f64, zero, negInf, posInf
  chck ((u64 0x_8000_0000_0000_0000).castTo_f64 == (-f64s.zero))                 "castTo_f64 works, bit representation for zero is correct"
  chck ((u64 0x_FFF0_0000_0000_0000).castTo_f64 == (f64s.negativeInfinity))      "castTo_f64 works, bit representation for negInf is correct"
  chck ((u64 0x_7FF0_0000_0000_0000).castTo_f64 == (f64s.positiveInfinity))      "castTo_f64 works, bit representation for posInf is correct"

  # castTo_u64
  chck ((-f64s.zero).castTo_u64 == 0x_8000_0000_0000_0000)                       "castTo_u64 works"
  chck ((f64s.negativeInfinity).castTo_u64 == 0x_FFF0_0000_0000_0000)            "castTo_u64 works"
  chck ((f64s.positiveInfinity).castTo_u64 == 0x_7FF0_0000_0000_0000)            "castTo_u64 works"


  fuzion.std.exit exitCode
