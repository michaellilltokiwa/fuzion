# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test sockets
#
# -----------------------------------------------------------------------

sockets =>

  localhost array u8 := [127, 0, 0, 1]
  port u16 := 9000

  # should result in connection refused
  # since no server is running yet...
  net.client localhost port
  say (net.connection net.client).last_error

  # reading/writing from/to closed connection
  say ((net.connection net.client).read 10)
  say ((net.connection net.client).write "Writing on closed connection".utf8)



  # start server in background
  concur.thread.spawn ()->

    # install server in env
    say (net.server net.family.ipv4 port)

    while net.server.is_active
    do
      net.server.accept
      if (net.connection net.server).is_active
        b := (net.connection net.server).read 10
        say "server, received msg: {b.bind String (d -> String.type.from_bytes  d)}"

        # read more than available
        b := (net.connection net.server).read 100
        say "server, received msg: {b.bind String (d -> String.type.from_bytes  d)}"

        (net.connection net.server).write "I am a response payload".utf8


  # wait for server to start
  time.nano.sleep (time.durations.ms 500)

  say "server: is_active {net.server.is_active}"


  # try start another server on same port in background
  concur.thread.spawn ()->

    # server is installed in env
    say (net.server net.family.ipv4 port)

    unit

  # wait for server to start
  time.nano.sleep (time.durations.ms 500)


  # write request to server and read response
  for _ in 1..2 do
    net.client localhost port

    (net.connection net.client).write "I am a request payload".utf8

    b := (net.connection net.client).read 10
    say "client, received msg: {b.bind String (d -> String.type.from_bytes  d)}"

    # read more than available
    b := (net.connection net.client).read 100
    say "client, received msg: {b.bind String (d -> String.type.from_bytes  d)}"


  # write request to server and read response
  for i in 1..5 do
    concur.thread.spawn ()->
      net.client localhost port

      (net.connection net.client).write "parallel request of client".utf8
      rr := (net.connection net.client).read 10

      # wait for clients to read/write
      time.nano.sleep (time.durations.ms 100)

      say "read successful: {rr.ok}"

      unit


  # wait for clients to read/write
  time.nano.sleep (time.durations.ms 500)


  # write request to server and read response
  concur.thread.spawn ()->

    net.client localhost port
    (net.connection net.client).read 10
    say "should not be reached since read blocks indefinitely"


  # wait for clients to read/write
  time.nano.sleep (time.durations.ms 500)
