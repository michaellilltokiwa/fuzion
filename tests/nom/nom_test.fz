# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test nom
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# test for nom, a parser combinator framework
#
nom_test : nom, nom.combinator, nom.string_parsers, nom.sequence, nom.branch, nom.multi =>


  # # NYI helper as long as type inference can figure out types for map_res
  #
  # NYI: these helpers crash C-backend currently
  #
  # error 1: NYI: in nom_test.hex_parser_test no targets for Call to nom_test.ref parser<string, Sequence<codepoint>, nom_test.hex_parser_test.hex_color>.parse target boxed(nom.combinator.ref map_inp<Sequence<codepoint>, string, Sequence<codepoint>, nom_test.hex_parser_test.hex_color>):nom.combinator.map_inp<Sequence<codepoint>, string, Sequence<codepoint>, nom_test.hex_parser_test.hex_color>
  #
  map_res_helper(O type, p parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint), mapper (Sequence codepoint) -> outcome O) parser (Sequence codepoint) (Sequence codepoint) O is
    map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) O p mapper

  map_res_helper2(O1, O2 type, p parser (Sequence codepoint) (Sequence codepoint) O1, mapper O1 -> outcome O2) parser (Sequence codepoint) (Sequence codepoint) O2 is
    map_res (Sequence codepoint) (Sequence codepoint) O1 O2 p mapper

  simple_parser_test is
    say ((to_string_parser whitespace0).parse "\n \tHello").asString.codepointLength



  hex_parser_test is
    hex_color(r,g,b u8) is
      redef asString string is
        "r: $r, g: $g, b: $b"

    is_valid(c codepoint) bool is
      codepoints.ascii_digit.contains c.val
        || (u32 0x41 .. 0x46).contains c.val

    # example: `A1` => u8
    parser_two_digit_hex := map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) u8 (take_while_m_n 2 2 (fun is_valid)) (o1 -> (strings.fromCodepoints o1).parse_u32(16).val.as_u8)
    # example: `#9F3A10` => tuple u8 u8 u8
    parser_hex_tuple := preceded (tag "#") (tuple3 parser_two_digit_hex parser_two_digit_hex parser_two_digit_hex)
    # example: `#9F3A10` => hex_color
    parser_hex_color_seq_codepoints := map_res (Sequence codepoint) (Sequence codepoint) (tuple u8 u8 u8) hex_color parser_hex_tuple (t -> (r,g,b) := t; hex_color r g b)
    # convert parser to take string not codepoints as input
    # NYI: using this crashes in c backend currently
    parser_hex_color := to_string_input parser_hex_color_seq_codepoints

    say (parser_hex_color_seq_codepoints.parse "#9F3A10".asCodepoints).asString   # NYI: asCodepoints, asString necessary, see issue #486
    say (parser_hex_color_seq_codepoints.parse "#9F3A1G".asCodepoints).asString   # NYI: asCodepoints, asString necessary, see issue #486
    say (parser_hex_color_seq_codepoints.parse "Hello".asCodepoints).asString     # NYI: asCodepoints, asString necessary, see issue #486
    say (parser_hex_color_seq_codepoints.parse "".asCodepoints).asString          # NYI: asCodepoints, asString necessary, see issue #486


  json_parser_test is

    json_value : choice string i64 f64 bool nil (Sequence json_value) (map string json_value) is
      redef asString string is
        match json_value.this
          s string => "\"$s\""
          i i64 => $i
          f f64 => $f
          b bool => $b
          n nil => "null"
          seq Sequence => $seq
          m map => $m

    # NYI escapings
    parser_string parser (Sequence codepoint) (Sequence codepoint) string :=
      map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) string (delimited (tag "\"") (take_while0 codepoint (c-> (c â‰  "\"") & (c â‰  "\\"))) (tag "\"")) (x -> strings.fromCodepoints x)
    # NYI fraction, negative numbers, exponents
    parser_number parser (Sequence codepoint) (Sequence codepoint) json_value :=
      map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) json_value (take_while1 (c -> codepoints.ascii_digit.contains c.val)) (x -> (strings.fromCodepoints x).parse_i64.val)
    parser_true parser (Sequence codepoint) (Sequence codepoint) json_value :=
      map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) json_value (tag "true") (x -> true)
    parser_false parser (Sequence codepoint) (Sequence codepoint) json_value :=
      map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) json_value (tag "false") (x -> false)
    parser_null parser (Sequence codepoint) (Sequence codepoint) json_value :=
      map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) json_value (tag "null") (x -> nil)

    jarray is
      parser_no_values parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=
        map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (Sequence json_value) whitespace0 (x -> lists.empty json_value)

      parser_comma_sep_value parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=
        separated_list1 (tag ",") jvalue.parser_lazy

      parser parser (Sequence codepoint) (Sequence codepoint) json_value is
        tmp parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=  delimited (tag "[") (alt [parser_comma_sep_value, parser_no_values]) (tag "]")
        map_res (Sequence codepoint) (Sequence codepoint) (Sequence json_value) json_value tmp (x->x)

    jobject is
      parser_key_value parser (Sequence codepoint) (Sequence codepoint) (tuple string json_value) :=
        separated_pair (delimited whitespace0 parser_string whitespace0) (tag ":") jvalue.parser_lazy

      parser_no_key_values parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) :=
        map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) whitespace0 (x -> lists.empty (tuple string json_value))

      parser_key_values parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) :=
        separated_list1 (tag ",") parser_key_value

      parser_object_seq_tuple parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) :=
        delimited (tag "\{") (alt [parser_key_values, parser_no_key_values]) (tag "}")
      parser parser (Sequence codepoint) (Sequence codepoint) json_value is
        map_res (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) json_value parser_object_seq_tuple (x -> mapOf x.asArray)

    jvalue is

      # parse true, false, [], {}, etc.
      parser_value parser (Sequence codepoint) (Sequence codepoint) json_value is
        alt (Sequence codepoint) (Sequence codepoint) json_value [
          map_res (Sequence codepoint) (Sequence codepoint) string json_value parser_string (x->x),
          parser_number,
          jobject.parser,
          jarray.parser,
          parser_number,
          parser_true,
          parser_false,
          parser_null]
      # parse true, false, [], {}, etc. enclosed in whitespace
      parser parser (Sequence codepoint) (Sequence codepoint) json_value is
        delimited (Sequence codepoint) (Sequence codepoint) json_value (Sequence codepoint) whitespace0 parser_value whitespace0

      parser_lazy parser (Sequence codepoint) (Sequence codepoint) json_value := as_lazy (Sequence codepoint) (Sequence codepoint) json_value ()->parser


    parser_json parser string (Sequence codepoint) json_value is
      to_string_input jvalue.parser

    say (parser_string.parse "\"I'm a utf-8 string ðŸ˜€\"After the string".asCodepoints).asString
    say (parser_number.parse "1234asdf".asCodepoints).asString
    say (parser_true.parse "true".asCodepoints).asString
    # parser true fails to parse false
    say (parser_true.parse "false".asCodepoints).asString

    say (jvalue.parser.parse "\"A string \"".asCodepoints).asString

    say (jvalue.parser.parse "\{  \"employee \":  \{  \"name \":  \"sonoo\",  \"salary \": 56000,  \"married \": true } }".asCodepoints).asString

  simple_parser_test
  hex_parser_test
  json_parser_test

