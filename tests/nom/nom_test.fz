# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test nom
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# test for nom, a parser combinator framework
#
nom_test : nom, nom.combinator, nom.string_parsers =>
  hex_color(r,g,b u8) is
    redef asString => "r: $r, g: $g, b: $b"

  is_valid(c codepoint) bool is
    codepoints.ascii_digit.contains c.val
      || (u32 0x41 .. 0x46).contains c.val

  parser_two_digit_hex := map_res (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) u8 (take_while_m_n 2 2 (fun is_valid)) (o1 -> (strings.fromCodepoints o1).parse_u32(16).val.as_u8)
  parser_hex_tuple := preceded (tag "#") (tuple3 parser_two_digit_hex parser_two_digit_hex parser_two_digit_hex)
  parser_hex_color_seq_codepoints := map_res (Sequence codepoint) (Sequence codepoint) (tuple u8 u8 u8) hex_color parser_hex_tuple (t -> (r,g,b) := t; hex_color r g b)
  parser_hex_color := to_string_input parser_hex_color_seq_codepoints

  match (parser_hex_color.parse "#9F3A10")
    s success =>
      say s.out
    e error =>
      say e

  match (parser_hex_color.parse "#9F3A1G")
    s success =>
      say s.out
    e error =>
      say e

  match (parser_hex_color.parse "Hello")
    s success =>
      say s.out
    e error =>
      say e

  match (parser_hex_color.parse "")
    s success =>
      say s.out
    e error =>
      say e

  match (to_string_output (to_string_input whitespace0)).parse " Hello"
    s success =>
      say s.out
      say "rest: {s.rest}"
    e error =>
      say e


