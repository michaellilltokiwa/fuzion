# references:
# <http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF>
# <https://github.com/jrp2014/fptest>

Qtest is

  r_f32 := [
    f32 2.0 ** 12 + 2.0,            # for 24 sig. bits,
    f32 2.0 ** 12 + 2.25,                # and 6 hex
    f32 16.0 ** 3.0 + 1.0 + f32 1.0 / 16.0 ** 2.0,    # 6 hex. IBM
    f32 2.0 ** 24.0 + 2.0,               # 48 bits CRAY -
    f32 2.0 ** 24.0 + 2.25,              # rounded
    f32 2.0 ** 24.0 + 3.0,               # 48 bits chopped
    # NYI
    # f32 94906267.0,                      # 53 sig. bits.
    # f32 94906267.0 + 0.25,               # 53 sig. bits.
    f32 2.0 ** 28.0 - 5.5,                 # PowerPC, i860
    f32 2.0 ** 28.0 - 4.5,                 # PowerPC, i860
    f32 2.0 ** 28.0 + 2.0,                 # 56 sig. bits,
    f32 2.0 ** 28.0 + 2.25,                # and 14 hex.
    f32 16.0 ** 7.0 + 1 + f32 1.0 / 16.0 ** 6.0,   # 14 hex. IBM
    f32 2.0 ** 32 + 2.0,             # 64 sig. bits.
    f32 2.0 ** 32 + 2.25,            # 64 sig. bits.
    ]

  r_f64 := [
    2.0**12 + 2.0,            # for 24 sig. bits,
    2.0**12 + 2.25,           # and 6 hex
    16.0**3.0 + 1.0 + 1.0/16.0**2.0,    # 6 hex. IBM
    2.0**24.0 + 2.0,            # 48 bits CRAY -
    2.0**24.0 + 2.25,           # rounded
    2.0**24.0 + 3.0,            # 48 bits chopped
    94906267.0,                 # 53 sig. bits.
    94906267.0 + 0.25,            # 53 sig. bits.
    2.0**28.0 - 5.5,             # PowerPC, i860
    2.0**28.0 - 4.5,             # PowerPC, i860
    2.0**28.0 + 2.0,             # 56 sig. bits,
    2.0**28.0 + 2.25,            # and 14 hex.
    16.0**7.0 + 1 + 1.0/16.0**6.0,   # 14 hex. IBM
    2.0**32 + 2.0,             # 64 sig. bits.
    2.0**32 + 2.25,            # 64 sig. bits.
    ]

  abs<T: float<T>>(x T) =>
    if x < x.zero
      -x
    else
      x

  log2<T: float<T>>(x T) =>
    two := x.one + x.one
    x.log(abs(x)) / x.log(two)

  min<T: float<T>>(x1, x2 T) =>
    if x1 < x2
      x1
    else
      x2

  signum<T: float<T>>(f T) =>
    if f <= f.zero || f == -f.zero
      "-"
    else
      "+"

  copy_sign<T: float<T>>(x, y T) =>
    if x.isNaN y
      x.NaN
    else if signum x == signum y
      x
    else
      -x

  qdrtc<T: float<T>>( p, q, r T) =>
    s := p.sqrt (q*q - p*r)
    S := q + copy_sign s q
    if S == p.zero then
      (r/p, r/p)
    else
      (r/S, S/p)

  qtrial<T: float<T>>(r T) =>
    two := r.one + r.one
    p := r-two
    q := r-r.one
    yak "qrdtc for r = $r"
    if p<=r.zero
      say " Qtrial(..., r) expects r > 2 ."
      r.NaN
    else if !((r-q) == r.one && (q-p)== r.one)
      say " r is too big for Qtrial(..., r)."
      r.NaN
    else
      qdrt := qdrtc( p, q, r)
      x1 := qdrt.values.0
      x2 := qdrt.values.1
      e1 := -log2( x1 - r.one )
      e2 := -log2( (x2 - r.one) - two/p )
      yak " gets $e1 and $e2 sig. bits"
      if !(x1 >= r.one)
        yak " and root $x1 isn't at least 1."
      say
      min(e1, e2)


  say "### f32"

  e := f32s.positiveInfinity
  for j in (1..r_f32.length) do
    t := qtrial(r_f32[j-1])
    if (t < e && !f32s.isNaN t) then
      set e := t
  say  " Worst accuracy is $e sig. bits"

  say "### f64"

  e := f64s.positiveInfinity
  for j in (1..r_f64.length) do
    t := qtrial(r_f64[j-1])
    if (t < e && !f64s.isNaN t) then
      set e := t
  say  " Worst accuracy is $e sig. bits"
