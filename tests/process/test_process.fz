test_process =>

  test(str String) is
    say "===  Test: $str  ==="

  test "write to stdin of process"
  say (process.spawn ["cat"] ()->
      process.spawned.env.write_string "Hello from the other side."
      say "close write: {process.spawned.env.close_write}"
      say "close write again: {process.spawned.env.close_write}"
      process.spawned.env.read_string
  )



  test "read stdout of process"
  say (process.spawn ["echo", "eecchhoo"] ()->
    process.spawned.env.read_string
  )



  test "pass environment variable"
  # NYI why do we have to specify type param?
  say (process.spawn (outcome String) ["printenv", "MYENVVAR"] (container.map_of [("MYENVVAR", "content")]) ()->
    process.spawned.env.read_string
  )



  test "read stdout blocks until stdin closed"
  say (process.spawn ["cat"] ()->

    p := process.spawned.env

    concur.thread.spawn (() ->
      time.nano.sleep (time.durations.ms 100)
      say "1) closing write"
      _ := p.close_write)

    # this read should block until stdin is closed
    say "2) read: {p.read_string}"
  )



  test "feed output of process 1 to process 2"
  say (process.spawn ["echo", "'feed me to cat'"] ()->
    p process.spawned =>
      match p | ["cat"]
        p process.spawned => say p.read_string
        error => say "error"
    error => say "error"
  )

  /*

  # create string of given byte size
  get_str(byte_size i32) =>
    ref : String
      utf8 Sequence u8 is
        (1..byte_size)
          .map u8 (x -> codepoint.type.zero_char)



  test "100kb argument, piped to another process"
  match process.spawn ["echo", "-n", (get_str 1E5)]
    p process.spawned =>
      match p | ["cat"]
        p2 process.spawned =>
          say p.read_string.val.byte_length
          say "exit code: {p.exit_code}"
        e error =>
          say e
    e error =>
      say e



  test "10mb write to stdin, piped to another process"
  match process.spawn ["cat"]
    p3 process.spawned =>
      concur.thread.spawn ()->
        time.nano.sleep (time.durations.s 1)
        say "start reading"
        while
          match p3.read_bytes 100
            Sequence => true
            * => false

      # NYI write should block here?
      say (p3.write_bytes (get_str 1E7).utf8)
      p3.close_write
      say "exit code: {p3.exit_code}"
    error =>

*/
