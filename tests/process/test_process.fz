test_process =>

  proc := fuzion.sys.process



  op := proc.create ["cat"]
  match op
    p fuzion.sys.process.r_process =>
      p.write "Hello from the other side."
      say "close write successful: {p.close_write}"
      say "close write successful: {p.close_write}"
      say p.read_string
      say "exit code: {p.wait}"
    error => say "error"



  match proc.create ["echo", "eecchhoo"]
    p fuzion.sys.process.r_process =>
      say p.read_string
      say "exit code: {p.wait}"
    error => say "error"



  match proc.create ["printenv", "MYENVVAR"] ["MYENVVAR=content"]
    p fuzion.sys.process.r_process =>
      say p.read_string
      say "exit code: {p.wait}"
    error => say "error"



  say ((proc.create ["echo", "'feed me to cat'"]) | (proc.create ["cat"]))



  op := proc.create ["cat"]
  match op
    p2 fuzion.sys.process.r_process =>

      concur.thread.spawn (() ->
        # wait 100ms
        time.nano.sleep (time.duration 1E8)
        say "closing write"
        _ := p2.close_write)

      # this read should block until stdin is closed
      say "read: {p2.read_string}"
      say "exit code: {p2.wait}"
    error => say "error"
