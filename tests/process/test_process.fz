test_process =>

  proc := fuzion.sys.process

  /*


  match proc.create ["cat"]
    p fuzion.sys.process.r_process =>
      p.write_string "Hello from the other side."
      say "close write successful: {p.close_write}"
      say "close write successful: {p.close_write}"
      say p.read_string
      say "exit code: {p.wait}"
    error => say "error"



  match proc.create ["echo", "eecchhoo"]
    p fuzion.sys.process.r_process =>
      say p.read_string
      say "exit code: {p.wait}"
    error => say "error"



  match proc.create ["printenv", "MYENVVAR"] ["MYENVVAR=content"]
    p fuzion.sys.process.r_process =>
      say p.read_string
      say "exit code: {p.wait}"
    error => say "error"



  say ((proc.create ["echo", "'feed me to cat'"]) | (proc.create ["cat"]))

  */
  /*
  for i in 1..2 do

    match proc.create ["cat"]
      p2 fuzion.sys.process.r_processes =>

        concur.thread.spawn (() ->
          time.nano.sleep (time.durations.seconds 1)
          say "closing write {p2.exit}")

        # this read should block until stdin is closed
        say "read: {p2.read_bytes 10}"
      error => say "error"

  time.nano.sleep (time.durations.seconds 5)
  */


  # match (proc.create ["cat"]) | (proc.create ["cat"])

  #   p3 fuzion.sys.process.r_processes =>
  #     concur.thread.spawn (() ->
  #       for res := p3.read_bytes 100, p3.read_bytes 100
  #       while res.ok do
  #         say "read {res.val.count}"
  #       say "not reading anymore"
  #       )

  #     # NYI write should block here?
  #     # NYI we want to be larger than pipe buffer here
  #     say "wrote {p3.write_bytes (array u8 1E2 idx->0)} bytes"
  #     say p3.exit
  #     time.nano.sleep (time.durations.s 1)
  #   e error =>
  #     say e




  match proc.create ["cat"]
    p fuzion.sys.process.r_processes =>
      concur.thread.spawn (() ->
        say (p.read_bytes 100)
      )

      # concur.thread.spawn (() ->
      #   say (p.write_bytes "abcd".utf8)
      #   say (p.write_bytes "defg".utf8)
      # )

      # concur.thread.spawn (() ->
      #   time.nano.sleep (time.durations.seconds 3)
      #   say "waiting for exit"
      #   say "{p.exit}")



    error => say "error"



  concur.thread.spawn (() ->
    say "hello from thread 1"
    time.nano.sleep (time.durations.seconds 1)
    say "hello from thread 2"
    )

  say "sleeping"
  time.nano.sleep (time.durations.seconds 10)
  say "sleeping finished"
