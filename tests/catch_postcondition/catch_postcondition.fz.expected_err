
error 1: Postcondition `equals result-x x` does not hold after call
Call stack:
fuzion.type.runtime.type.fault.type.install_default.λ.call#1: $MODULE/fuzion/runtime/fault.fz:38:7:
      fuzion.sys.fatal_fault kind msg
------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fuzion.runtime.fault.cause#1: $MODULE/eff/fallible.fz:35:6:
  => h e
-----^
fuzion.type.runtime.type.post_fault.type.install_default.λ.call#1: $MODULE/fuzion/runtime/post_fault.fz:39:7:
      fuzion.runtime.fault.cause ("postcondition", msg)).default
------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
fuzion.runtime.post_fault.cause#1: $MODULE/eff/fallible.fz:35:6:
  => h e
-----^
fuzion.runtime.postcondition_fault#1: $MODULE/fuzion/runtime/post_fault.fz:58:43:
public postcondition_fault(msg String) => post_fault.cause msg
------------------------------------------^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
(catch_postcondition.test#1 i16).post double: --CURDIR--/catch_postcondition.fz:286:8:
  say (test i32)
-------^^^^
(catch_postcondition.test#1 i16).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 13 times ...

catch_postcondition.test#1 i16: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:56:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------------------------^^^^
catch_postcondition.loop.λ.call: --CURDIR--/catch_postcondition.fz:271:28:
           option tries[c].call
---------------------------^^^^
(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.try: $MODULE/eff/fallible.fz:75:23:
         redef try => code_try.call
----------------------^^^^^^^^^^^^^
(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.res.λ.call.λ.call: $MODULE/eff/fallible.fz:121:13:
      ).run eff.handle.this.try (()->catch m.get.get)
------------^^^^^^^^^^^^^^^^^^^
(fuzion.runtime.fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.fault.run#3 (option String): <source position not available>:

(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.res.λ.call: $MODULE/eff/fallible.fz:118:7:
      (F.new e->
------^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
((eff.ref handle (tuple String String) fuzion.runtime.fault (option String)).lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((eff.ref handle (tuple String String) fuzion.runtime.fault (option String)).lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(eff.ref handle (tuple String String) fuzion.runtime.fault (option String)).lm.go#2 (option String): <source position not available>:

(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.res: $MODULE/eff/fallible.fz:116:10:
  res => lm.go ()->
---------^^^^^^^^^^
      m := lm.env.new (option ERROR nil)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      (F.new e->
^^^^^^^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(fuzion.type.runtime.type.fault.type.try (option String)).catch#1: $MODULE/eff/fallible.fz:74:7:
      (ref : eff.handle ERROR fallible.this T
------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef try => code_try.call
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef catch(e ERROR) => code_catch e
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      ).res
^^^^^^^^^^^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:272:11:
         .catch s->
----------^^^^^
fuzion.runtime.post_fault.cause#1: --CURDIR--/catch_postcondition.fz:267:3:
  for
--^
fuzion.runtime.postcondition_fault#1: $MODULE/fuzion/runtime/post_fault.fz:58:43:
public postcondition_fault(msg String) => post_fault.cause msg
------------------------------------------^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:38:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------^^^^
catch_postcondition.loop.λ.call: --CURDIR--/catch_postcondition.fz:271:28:
           option tries[c].call
---------------------------^^^^
(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.try: $MODULE/eff/fallible.fz:75:23:
         redef try => code_try.call
----------------------^^^^^^^^^^^^^
(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.res.λ.call.λ.call: $MODULE/eff/fallible.fz:121:13:
      ).run eff.handle.this.try (()->catch m.get.get)
------------^^^^^^^^^^^^^^^^^^^
(fuzion.runtime.fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.fault.run#3 (option String): <source position not available>:

(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.res.λ.call: $MODULE/eff/fallible.fz:118:7:
      (F.new e->
------^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
((eff.ref handle (tuple String String) fuzion.runtime.fault (option String)).lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((eff.ref handle (tuple String String) fuzion.runtime.fault (option String)).lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(eff.ref handle (tuple String String) fuzion.runtime.fault (option String)).lm.go#2 (option String): <source position not available>:

(fuzion.type.runtime.type.fault.type.try (option String)).catch#1.anonymous.res: $MODULE/eff/fallible.fz:116:10:
  res => lm.go ()->
---------^^^^^^^^^^
      m := lm.env.new (option ERROR nil)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      (F.new e->
^^^^^^^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(fuzion.type.runtime.type.fault.type.try (option String)).catch#1: $MODULE/eff/fallible.fz:74:7:
      (ref : eff.handle ERROR fallible.this T
------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef try => code_try.call
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef catch(e ERROR) => code_catch e
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      ).res
^^^^^^^^^^^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:272:11:
         .catch s->
----------^^^^^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:267:3:
  for
--^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 13 times ...

catch_postcondition.test#1 i16: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:56:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------------------------^^^^
catch_postcondition.loop.λ.call: --CURDIR--/catch_postcondition.fz:252:28:
           option tries[c].call
---------------------------^^^^
(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.try: $MODULE/eff/fallible.fz:75:23:
         redef try => code_try.call
----------------------^^^^^^^^^^^^^
(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.res.λ.call.λ.call: $MODULE/eff/fallible.fz:121:13:
      ).run eff.handle.this.try (()->catch m.get.get)
------------^^^^^^^^^^^^^^^^^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.res.λ.call: $MODULE/eff/fallible.fz:118:7:
      (F.new e->
------^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
((eff.ref handle String fuzion.runtime.post_fault (option String)).lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((eff.ref handle String fuzion.runtime.post_fault (option String)).lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(eff.ref handle String fuzion.runtime.post_fault (option String)).lm.go#2 (option String): <source position not available>:

(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.res: $MODULE/eff/fallible.fz:116:10:
  res => lm.go ()->
---------^^^^^^^^^^
      m := lm.env.new (option ERROR nil)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      (F.new e->
^^^^^^^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1: $MODULE/eff/fallible.fz:74:7:
      (ref : eff.handle ERROR fallible.this T
------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef try => code_try.call
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef catch(e ERROR) => code_catch e
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      ).res
^^^^^^^^^^^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:253:11:
         .catch s->
----------^^^^^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:248:3:
  for
--^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:38:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------^^^^
catch_postcondition.loop.λ.call: --CURDIR--/catch_postcondition.fz:252:28:
           option tries[c].call
---------------------------^^^^
(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.try: $MODULE/eff/fallible.fz:75:23:
         redef try => code_try.call
----------------------^^^^^^^^^^^^^
(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.res.λ.call.λ.call: $MODULE/eff/fallible.fz:121:13:
      ).run eff.handle.this.try (()->catch m.get.get)
------------^^^^^^^^^^^^^^^^^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.res.λ.call: $MODULE/eff/fallible.fz:118:7:
      (F.new e->
------^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
((eff.ref handle String fuzion.runtime.post_fault (option String)).lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((eff.ref handle String fuzion.runtime.post_fault (option String)).lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(eff.ref handle String fuzion.runtime.post_fault (option String)).lm.go#2 (option String): <source position not available>:

(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1.anonymous.res: $MODULE/eff/fallible.fz:116:10:
  res => lm.go ()->
---------^^^^^^^^^^
      m := lm.env.new (option ERROR nil)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      (F.new e->
^^^^^^^^^^^^^^^^
          m <- e
^^^^^^^^^^^^^^^^
          F.env.return
^^^^^^^^^^^^^^^^^^^^^^
      ).run eff.handle.this.try (()->catch m.get.get)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(fuzion.type.runtime.type.post_fault.type.try (option String)).catch#1: $MODULE/eff/fallible.fz:74:7:
      (ref : eff.handle ERROR fallible.this T
------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef try => code_try.call
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         redef catch(e ERROR) => code_catch e
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      ).res
^^^^^^^^^^^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:253:11:
         .catch s->
----------^^^^^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:248:3:
  for
--^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 13 times ...

catch_postcondition.test#1 i16: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:56:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------------------------^^^^
catch_postcondition.loop.λ.call: --CURDIR--/catch_postcondition.fz:233:28:
           option tries[c].call
---------------------------^^^^
(catch_postcondition.try_post (option String)).catch#1.h.try: --CURDIR--/catch_postcondition.fz:188:34:
        redef try             => code_try()
---------------------------------^^^^^^^^
(catch_postcondition.try_post (option String)).catch#1.h.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

(catch_postcondition.try_post (option String)).catch#1.h.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
((catch_postcondition.try_post (option String)).catch#1.h.lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((catch_postcondition.try_post (option String)).catch#1.h.lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(catch_postcondition.try_post (option String)).catch#1.h.lm.go#2 (option String): <source position not available>:

(catch_postcondition.try_post (option String)).catch#1.h: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
(catch_postcondition.try_post (option String)).catch#1: --CURDIR--/catch_postcondition.fz:190:7:
      h.res
------^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:234:11:
         .catch s->
----------^^^^^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:229:3:
  for
--^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:38:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------^^^^
catch_postcondition.loop.λ.call: --CURDIR--/catch_postcondition.fz:233:28:
           option tries[c].call
---------------------------^^^^
(catch_postcondition.try_post (option String)).catch#1.h.try: --CURDIR--/catch_postcondition.fz:188:34:
        redef try             => code_try()
---------------------------------^^^^^^^^
(catch_postcondition.try_post (option String)).catch#1.h.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

(catch_postcondition.try_post (option String)).catch#1.h.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
((catch_postcondition.try_post (option String)).catch#1.h.lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((catch_postcondition.try_post (option String)).catch#1.h.lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(catch_postcondition.try_post (option String)).catch#1.h.lm.go#2 (option String): <source position not available>:

(catch_postcondition.try_post (option String)).catch#1.h: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
(catch_postcondition.try_post (option String)).catch#1: --CURDIR--/catch_postcondition.fz:190:7:
      h.res
------^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:234:11:
         .catch s->
----------^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:229:3:
  for
--^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.res2.λ.call: --CURDIR--/catch_postcondition.fz:220:21:
  res2 => try_post (test i32) || (s->say "*** failed: $s ***"; test u64)
--------------------^^^^
(catch_postcondition.try_post String).catch#1.h.try: --CURDIR--/catch_postcondition.fz:188:34:
        redef try             => code_try()
---------------------------------^^^^^^^^
(catch_postcondition.try_post String).catch#1.h.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 String).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 String: <source position not available>:

(catch_postcondition.try_post String).catch#1.h.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
((catch_postcondition.try_post String).catch#1.h.lm.go#2 String).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((catch_postcondition.try_post String).catch#1.h.lm.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(catch_postcondition.try_post String).catch#1.h.lm.go#2 String: <source position not available>:

(catch_postcondition.try_post String).catch#1.h: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
(catch_postcondition.try_post String).catch#1: --CURDIR--/catch_postcondition.fz:190:7:
      h.res
------^
(catch_postcondition.try_post String).infix ||#1: --CURDIR--/catch_postcondition.fz:201:40:
    infix || (code_catch String->T) => catch code_catch
---------------------------------------^^^^^
catch_postcondition.res2: --CURDIR--/catch_postcondition.fz:220:31:
  res2 => try_post (test i32) || (s->say "*** failed: $s ***"; test u64)
------------------------------^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:221:7:
  say res2
------^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.res.λ.call: --CURDIR--/catch_postcondition.fz:208:12:
           test i32
-----------^^^^
(catch_postcondition.try_post String).catch#1.h.try: --CURDIR--/catch_postcondition.fz:188:34:
        redef try             => code_try()
---------------------------------^^^^^^^^
(catch_postcondition.try_post String).catch#1.h.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 String).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 String: <source position not available>:

(catch_postcondition.try_post String).catch#1.h.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
((catch_postcondition.try_post String).catch#1.h.lm.go#2 String).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((catch_postcondition.try_post String).catch#1.h.lm.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(catch_postcondition.try_post String).catch#1.h.lm.go#2 String: <source position not available>:

(catch_postcondition.try_post String).catch#1.h: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
(catch_postcondition.try_post String).catch#1: --CURDIR--/catch_postcondition.fz:190:7:
      h.res
------^
catch_postcondition.res: --CURDIR--/catch_postcondition.fz:209:11:
         .catch s->
----------^^^^^
(catch_postcondition.test#1 i16).double#1: --CURDIR--/catch_postcondition.fz:212:7:
  say res
------^^^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 13 times ...

catch_postcondition.test#1 i16: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:56:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------------------------^^^^
catch_postcondition.loop.h.try: --CURDIR--/catch_postcondition.fz:159:44:
      redef try option String  => tries[c].call
-------------------------------------------^^^^
catch_postcondition.loop.h.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

catch_postcondition.loop.h.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
(catch_postcondition.loop.h.lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
(catch_postcondition.loop.h.lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
catch_postcondition.loop.h.lm.go#2 (option String): <source position not available>:

catch_postcondition.loop.h: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:161:10:
    r := h.res
---------^
fuzion.runtime.postcondition_fault#1: --CURDIR--/catch_postcondition.fz:157:3:
  for c in tries.indices do
--^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:38:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------^^^^
catch_postcondition.loop.h.try: --CURDIR--/catch_postcondition.fz:159:44:
      redef try option String  => tries[c].call
-------------------------------------------^^^^
catch_postcondition.loop.h.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

catch_postcondition.loop.h.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
(catch_postcondition.loop.h.lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
(catch_postcondition.loop.h.lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
catch_postcondition.loop.h.lm.go#2 (option String): <source position not available>:

catch_postcondition.loop.h: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
catch_postcondition.loop: --CURDIR--/catch_postcondition.fz:161:10:
    r := h.res
---------^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:157:3:
  for c in tries.indices do
--^
(catch_postcondition.test#1 i16).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 8 times ...

catch_postcondition.test#1 i16: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:56:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------------------------^^^^
catch_postcondition.z.try: --CURDIR--/catch_postcondition.fz:146:43:
    redef try option String  => tries[c0].call
------------------------------------------^^^^
catch_postcondition.z.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

catch_postcondition.z.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
(catch_postcondition.z.lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
(catch_postcondition.z.lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
catch_postcondition.z.lm.go#2 (option String): <source position not available>:

catch_postcondition.z: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
catch_postcondition.z.catch#1: --CURDIR--/catch_postcondition.fz:147:117:
    redef catch(s String) option String => say "*** failed: $s ***"; c0 <- c0.get + 1; if c0.get < tries.count then z.res else nil
--------------------------------------------------------------------------------------------------------------------^
catch_postcondition.z.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:24:
        ).run try (()->catch m.get.get)
-----------------------^^^^^
fuzion.runtime.post_fault.abort: $MODULE/effect.fz:101:14:
      nil => def()
-------------^^^
fuzion.runtime.post_fault.precall abort: $MODULE/effect.fz:66:3:
  pre
--^^^
    safety: effect.is_installed effect.this
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    safety: abortable
^^^^^^^^^^^^^^^^^^^^^
fuzion.runtime.post_fault.return: $MODULE/effect.fz:112:5:
    abort
----^^^^^
fuzion.runtime.post_fault.precall return: $MODULE/effect.fz:109:3:
  pre
--^^^
    safety: abortable
^^^^^^^^^^^^^^^^^^^^^
catch_postcondition.z.λ.call.λ.call#1: --CURDIR--/catch_postcondition.fz:107:27:
            rt.post_fault.return
--------------------------^^^^^^
fuzion.runtime.post_fault.cause#1: $MODULE/eff/fallible.fz:35:6:
  => h e
-----^
fuzion.runtime.postcondition_fault#1: $MODULE/fuzion/runtime/post_fault.fz:58:43:
public postcondition_fault(msg String) => post_fault.cause msg
------------------------------------------^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:141:38:
  tries array ()->String := [ (() -> test i32), (() -> test i16), (() -> test i64) ]
-------------------------------------^^^^
catch_postcondition.z.try: --CURDIR--/catch_postcondition.fz:146:43:
    redef try option String  => tries[c0].call
------------------------------------------^^^^
catch_postcondition.z.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 (option String)).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 (option String): <source position not available>:

catch_postcondition.z.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
(catch_postcondition.z.lm.go#2 (option String)).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
(catch_postcondition.z.lm.Effect_Call (option String)).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
catch_postcondition.z.lm.go#2 (option String): <source position not available>:

catch_postcondition.z: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
fuzion.runtime.postcondition_fault#1: --CURDIR--/catch_postcondition.fz:149:7:
  say z.res
------^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.anonymous.try: --CURDIR--/catch_postcondition.fz:129:7:
      test i32
------^^^^
(catch_postcondition.ref handle_post String).λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 String).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 String: <source position not available>:

(catch_postcondition.ref handle_post String).λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
((catch_postcondition.ref handle_post String).lm.go#2 String).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
((catch_postcondition.ref handle_post String).lm.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
(catch_postcondition.ref handle_post String).lm.go#2 String: <source position not available>:

catch_postcondition.anonymous: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
fuzion.runtime.postcondition_fault#1: --CURDIR--/catch_postcondition.fz:127:8:
  say (ref : handle_post String
-------^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.y.try: --CURDIR--/catch_postcondition.fz:116:30:
    redef try             => test i32
-----------------------------^^^^
catch_postcondition.y.λ.call.λ.call: --CURDIR--/catch_postcondition.fz:108:15:
        ).run try (()->catch m.get.get)
--------------^^^
(fuzion.runtime.post_fault.run#3 String).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 String: <source position not available>:

catch_postcondition.y.λ.call: --CURDIR--/catch_postcondition.fz:108:11:
        ).run try (()->catch m.get.get)
----------^^^
(catch_postcondition.y.lm.go#2 String).λ.call: $MODULE/effect.fz:208:23:
    cf := Effect_Call f
----------------------^
(catch_postcondition.y.lm.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
catch_postcondition.y.lm.go#2 String: <source position not available>:

catch_postcondition.y: --CURDIR--/catch_postcondition.fz:103:15:
    res := lm.go ()->
--------------^^
fuzion.runtime.post_fault.precall abort: --CURDIR--/catch_postcondition.fz:119:7:
  say y.res
------^
catch_postcondition.λ.call#1: --CURDIR--/catch_postcondition.fz:83:21:
      rt.post_fault.abort).run
--------------------^^^^^
fuzion.runtime.post_fault.cause#1: $MODULE/eff/fallible.fz:35:6:
  => h e
-----^
fuzion.runtime.postcondition_fault#1: $MODULE/fuzion/runtime/post_fault.fz:58:43:
public postcondition_fault(msg String) => post_fault.cause msg
------------------------------------------^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).post double: --CURDIR--/catch_postcondition.fz:38:9:
        equals result-x x
--------^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).double#1: --CURDIR--/catch_postcondition.fz:37:7:
      post
------^^^^
        equals result-x x
^^^^^^^^^^^^^^^^^^^^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:21:
    for v := T.one, double v
--------------------^^^^^^
(catch_postcondition.test#1 i32).loop: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
... repeated 29 times ...

catch_postcondition.test#1 i32: --CURDIR--/catch_postcondition.fz:43:5:
    for v := T.one, double v
----^
catch_postcondition.λ.call: --CURDIR--/catch_postcondition.fz:84:6:
    (test i32)
-----^^^^
(fuzion.runtime.post_fault.run#3 String).λ.call: $MODULE/effect.fz:98:23:
    cf := Effect_Call f
----------------------^
(fuzion.runtime.post_fault.Effect_Call String).call: $MODULE/effect.fz:154:18:
      set res := f()
-----------------^
fuzion.runtime.post_fault.run#3 String: <source position not available>:

catch_postcondition: --CURDIR--/catch_postcondition.fz:83:28:
      rt.post_fault.abort).run
---------------------------^^^

*** fatal errors encountered, stopping.
one error.
