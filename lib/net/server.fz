# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature net.server
#
# -----------------------------------------------------------------------



private server(
  state outcome i64,
  p protocol.protocol_choice,
  m effectMode.val,
  _ unit
) : effect m
is

  # get the last error that occured
  last_error => state.bind unit (_ -> unit)

  # is the server running?
  is_active =>
    state.ok


  # close server, stop listening on port
  close is
    (channel server).close
    match state
      d i64 =>
        match fuzion.sys.net0.close d
          unit =>
            server (error "not initialized") nil effectMode.repl unit
          error error =>
            server error nil effectMode.repl unit
      * =>
    unit


  # accept new TCP connection
  # does nothing for UDP etc.
  # blocks until connection is established
  # NYI we may want to close on server on certain errors?
  accept is
    match state
      d i64 =>
        match p
          protocol.tcp => channel server (fuzion.sys.net0.accept d) true
          * => channel server state false
      error =>
        channel server (error "not initialized") true
    unit


  # accept new TCP connection in new thread, then runs code
  # runs code immediately for UDP etc.
  # NYI should need effect thread pool
  accept_in_thread(code () -> unit) is
    match state
      d i64 =>
        concur.thread.spawn ()->
          match p
            protocol.tcp =>
              channel server (fuzion.sys.net0.accept d) true
              code()
            * =>
              channel server state true
              code()
      error =>
        channel server (error "not initialized") true
    unit


# open new server on port
# closes currently installed server
# NYI blocking / none blocking
server(f family.family_choice, p protocol.protocol_choice, port u16) outcome unit is
  server.close

  match init_ip_server f p port
    desc i64 =>
      server desc p effectMode.repl unit
      unit
    e error =>
      e


# get currently installed server from env
server =>
  if !effects.exists server
    server (error "not initialized") nil effectMode.default unit
  server.env


Server_Provider ref is
  initialize outcome i64 is abstract


# opens sockets, binds to port and sets socket to listening
private init_ip_server(f family.family_choice, p protocol.protocol_choice, port u16) outcome i64 is
  any_addr := (
    match f
      family.ipv4 => "0.0.0.0"
      family.ipv6 => "0:0:0:0:0:0:0:0"
      family.local => panic "NYI"
  )
  backlog := 10
  s net.socket_type.socket_type_choice := (
    match p
      protocol.tcp => net.socket_type.stream
      protocol.udp => net.socket_type.datagram
      *   => net.socket_type.raw
    )

  # bind to port
  match fuzion.sys.net0.bind f.as_num s.as_num p.as_num any_addr port
    err error => err
    sd i64  =>
      match p
        protocol.tcp =>
          # listen
          listen_res := fuzion.sys.net0.listen sd backlog
          if listen_res != 0
            fuzion.sys.net0.close sd
            error "listening on socket failed with error $listen_res."
          else
            sd
        * =>
          sd
