# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Indexable_Sequence
#
# -----------------------------------------------------------------------

# This interface is to be used by data types like array
# where index access and count have complexity in O(1)
#
public Indexable_Sequence(public T type) ref : Sequence T is


  # the length of this sequence
  #
  public length => count


  # is this sequence known to be finite?  For infinite sequences, features like
  # count diverge.
  #
  public redef finite => true


  # check if argument is a valid index in this array.
  #
  # Unlike for general Sequences, this perfoms in O(1).
  #
  public redef is_valid_index(i i32) => 0 ≤ i ≤ length


  # create a list that consists of the elements of this Sequence except the first
  # n elements
  #
  # For arrays, this has performance in O(1).
  #
  public redef drop (n i32) =>
    as_list (max 0 n)


  # a sequence of all valid indices to access this array. Useful e.g., for
  # `for`-loops:
  #
  #   for i in arr.indices do
  #     say arr[i]
  #
  public indices => 0..length-1


  # create an array backed version of this sequence in case this is not array
  # backed.  This will ensure that operations like index[] or drop perform
  # in constant time.
  #
  # returns Sequence.this if is_array_backed.
  #
  public redef as_array_backed Indexable_Sequence T
  =>
    Indexable_Sequence.this


  # create a list from this array starting at the given index
  #
  public as_list(i i32) list T
    pre
      debug: i ≥ 0
  =>
    (slice i length).as_list


  # create a slice from this array's elements at index 'from' (included)
  # up to 'to' (excluded).
  #
  # Complexity:
  # index access : O(1)
  # count        : O(1)
  #
  public redef slice(from, to i32) Indexable_Sequence T
  =>
    array_slice Indexable_Sequence.this from to



  array_slice(seq Indexable_Sequence T, from, to i32) : Indexable_Sequence T is

    # this array slice as a list
    #
    public redef as_list list T =>
      if to ≤ from
        nil
      else
        array_slice.this.array_cons from to

    # get the contents of this slice at the given index
    #
    public redef index [ ] (i i32) T
    =>
      seq[from+i]

    # is this sequence known to be finite?  For infinite sequences, features like
    # count diverge.
    #
    public redef finite => true


    # redefines Sequence.count for array.slice,
    # reducing complexity from O(n) to O(1).
    #
    public redef count => to-from


    # check if argument is a valid index in this Indexable_Sequence.
    #
    # Unlike for general Sequences, this perfoms in O(1).
    #
    public redef is_valid_index(i i32) => 0 ≤ i ≤ array_slice.this.count


    # create a list that consists of the elements of this Sequence except the first
    # n elements
    #
    # For arrays, this has performance in O(1).
    #
    public redef drop (n i32) =>
      seq
        .slice from+(max 0 n) to
        .as_list


  # create a cons cell for a list of this Indexable_Sequence starting at the given
  # index `i` and up to `to`
  #
  array_cons (i, to i32) : Cons T (list T)
    pre
      debug: 0 ≤ i < to ≤ count
  is
    head => Indexable_Sequence.this[i]
    tail => (slice i+1 to).as_list


  # map the array to a new array applying function f to all elements
  #
  public map_to_array(B type, f T -> B) array B =>
    array B length (i -> f Indexable_Sequence.this[i])


  # variant of map which additionally passes the index to
  # the mapping function f
  #
  public map_indexed(B type, f (T, i32) -> B) Indexable_Sequence B =>
    array B length (i -> f Indexable_Sequence.this[i] i)


  # fold the elements of this Indexable_Sequence using the given monoid.
  #
  # e.g., to sum the elements of an Indexable_Sequence of i32, use a.fold i32.sum
  #
  public redef fold (m Monoid T) => fold 0 m.e m


  # fold the elements of this Indexable_Sequence using the given monoid and initial value
  #
  # Used to fold an Indexable_Sequence tail-recursively
  #
  public fold (i i32, s T, m Monoid T) T
    pre
      debug: 0 ≤ i ≤ length
  =>
    if i = length
      s
    else
      fold i+1 (m.op s Indexable_Sequence.this[i]) m


  # apply f to all elements in this Indexable_Sequence
  public redef for_each (f T -> unit) unit =>
    for i in indices do
      f index[](i)


  # create a list from this Indexable_Sequence
  #
  public redef as_list => as_list 0


  # reverse the order of the elements in this Indexable_Sequence
  #
  public redef reverse Indexable_Sequence T =>
    array T length (i -> Indexable_Sequence.this[length-1-i])



  # get a list of tuples indices and elements in this array
  #
  public enumerate list (tuple i32 T) =>
    if length = 0
      nil
    else
      enumerate_cons 0


  # create a cons cell for a list of tuples of this array's indices and elements
  # starting at the given indices.
  #
  enumerate_cons (i i32) : Cons (i32, T) (list (tuple i32 T))
    pre
      debug: 0 ≤ i
      debug: i < length
  is
    head => (i, index[] i)
    tail list (tuple i32 T) =>
      if i < length-1 then enumerate_cons i+1
      else                 nil

