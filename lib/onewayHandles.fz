# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature handles
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# onewayHandles provide a means to create handles that refer to update-able
# cells using a one-way monad.
#
# onewayHandles is a one-way state monad. It provides features to create
# several handles that refer to modifiable value and features to 'get', 'put'
# or 'update' this value.
#
# This monad is fully functional, it does not mutate data but creates a long
# sequence to remember updates
#
# NYI: handling of one-way monads is completely experimental
#
private onewayHandles/*<X>*/(
  # the inner value of this monad
  # v X
  n i32,
  s Sequence<tuple<i32,i32>>,
  rr option<()->unit>
  ) : onewayMonad rr
is

  # a one-way feature to create a new handle and update the monad
  # in the current environment
  #
  #
  new/*<T>*/ (
    # initial value refered to by the new handle
    w i32/*T*/
    ) /* one way! */
   =>
    res := onewayHandle n
    onewayHandles n+1 ([(n,w)] ++ s) nil
    res


  # a one-way feature to read the value refered to by a given handle
  #
  get/*<T>*/ (
    # a handle created by 'new'
    h onewayHandle/*<T>*/
    ) /* one way! */
   =>
    for x in s
    until x.values.0 == h.x
      res := x.values.1
      onewayHandles n [x]++s nil
      res
    else
      fuzion.std.panic "no entry for {h.x} found"


  # a one-way feature to write the value refered to by a given handle
  #
  put/*<T>*/ (
    # a handle created by 'new'
    h onewayHandle/*<T>*/,

    # the new value to be stored with 'h'
    w i32/*T*/) /* one way! */
   =>
    onewayHandles n ([(h.x,w)] ++ s) nil


  # a one-way feature to read and update the value refered to by a
  # given handle
  #
  update/*<T>*/ (
    # a handle created by 'new'
    h onewayHandle/*<T>*/,

    # function calculcating the new value from the old value
    f i32->i32/*T->T*/
    ) /* one way! */
   =>
    for x in s
    until x.values.0 == h.x
      (onewayHandles n ([(h.x,f x.values.1)] ++ s) nil).get h
    else
      fuzion.std.panic "no entry for {h.x} found"


#  infix >>= (f X -> onewayHandles<X>) => bind<X> f

#  bind <B> (f X -> onewayHandles<B>) onewayHandles<B> is
#    onewayHandles<B> (f v).v

#  return<B> (w B) => onewayHandles w


# short-hand for creating an empty set of handles of given type.
#
onewayHandles(rr ()->unit) =>
  onewayHandles 0 Sequences.empty<tuple<i32,i32>> rr
  unit

# handle value created by 'handles.new'
#
private onewayHandle/*<T>*/ (
  private x i32/*T*/
  ) ref
is
#  private put(new_x i32/*T*/) is
#    set x := new_x
