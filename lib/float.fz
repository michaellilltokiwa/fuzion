# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature float
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# float -- floating point values
#
#
# float is the abstract parent of concrete floating point features such as
# f32 or f64.
#
float : numeric is


  # preconditions for basic operations: true if the operation's result is
  # representable for the given values.  For IEEE_754, all operations are
  # defined for all values.
  #
  redef prefix +! bool is true
  redef prefix -! bool is true
  redef infix +! (other float.this.type) bool is true
  redef infix -! (other float.this.type) bool is true
  redef infix *! (other float.this.type) bool is true
  redef infix /! (other float.this.type) bool is true
  redef infix %! (other float.this.type) bool is true
  redef infix **!(other float.this.type) bool is true

  # NYI: These redefinitions are required to avoid errors when removing the
  # type parameter from numeric. Why?
  redef infix + (other float.this.type) float.this.type is abstract
  redef infix - (other float.this.type) float.this.type is abstract
  redef infix * (other float.this.type) float.this.type is abstract
  redef infix / (other float.this.type) float.this.type is abstract
  redef infix % (other float.this.type) float.this.type is abstract
  redef infix ** (other float.this.type) float.this.type is abstract


  # convert a float value to i64 dropping any fraction.
  # the value must be in the range of i64
  #
  as_i64 i64 is abstract


  # convert a float value to i32 dropping any fraction.
  # the value must be in the range of i32
  #
  as_i32 => as_i64.as_i32


  fract float.this.type is abstract


  # round floating point number
  # ties to away (0.5 => 1; -0.5 => -1; etc.)
  #
  # NYI this could be made faster, see here:
  # https://cs.opensource.google/go/go/+/refs/tags/go1.18.1:src/math/floor.go;l=79
  round float.this.type is
    if thiz < float.this.type.zero
      -(-thiz).round
    else if fract = float.this.type.zero
      thiz
    else
      (thiz + float.this.type.one/float.this.type.two).floor


  # floor: the greatest integer lower or equal to this
  floor float.this.type is
    if fract < float.this.type.zero
      thiz - fract - float.this.type.one
    else
      thiz - fract


  # ceiling: the smallest integer greater or equal to this
  ceil float.this.type is
    if fract ≤ float.this.type.zero
      thiz - fract
    else
      thiz - fract + float.this.type.one


  # number of bits used for mantissa,
  # including leading '1' that is not actually stored
  #
  type.significand_bits i32 is abstract

  # number of bits used for exponent
  #
  type.exponent_bits i32 is abstract


  # the amount of bits that are used to encode the mantissa
  type.mantissa_bits => significand_bits - 1


  # number of bytes required to store this value
  #
  type.bytes i32 is abstract


  # number of bits required to store this value
  #
  type.size => 8*bytes


  # eulers number 2.72..
  #
  type.ℇ float.this.type is abstract


  # pi 3.14...
  #
  type.π float.this.type is abstract


  # conversion
  #

  # convert an i64 value to a floating point value
  #
  # if the value cannot be represented exactly, the result is either
  # the nearest higher or nearest lower value
  #
  type.from_i64(val i64) float.this.type is abstract


  type.exponent_range => -min_exp..max_exp


  # non signaling not a number
  #
  type.quiet_NaN => zero / zero


  # not a number
  #
  type.NaN => quiet_NaN


  # is not a number?
  #
  type.is_NaN (val float.this.type) bool is abstract


  type.negative_infinity => -one / zero


  type.positive_infinity => one / zero


  # infinity
  #
  type.infinity => positive_infinity


  type.min_exp i32 is abstract
  type.max_exp i32 is abstract
  type.min_positive float.this.type is abstract
  type.max float.this.type is abstract
  type.epsilon float.this.type is abstract


  # square root
  #
  type.square_root (val float.this.type) float.this.type is abstract


  # square root alias
  #
  type.sqrt (val float.this.type) => square_root val


  # the `val`-th power of ℇ
  # i.e. ℇᵛᵃˡ
  #
  type.exp (val float.this.type) float.this.type is abstract


  # logarithm with base ℇ
  #
  type.log (val float.this.type) float.this.type is abstract


  # logarithm with base `base`
  #
  type.log (base, val float.this.type) float.this.type
  pre base > zero
  is
    (log val) / (log base)


  # trigonometric

  type.sin  (val float.this.type) float.this.type is abstract
  type.cos  (val float.this.type) float.this.type is abstract
  type.tan  (val float.this.type) float.this.type is abstract
  type.asin (val float.this.type) float.this.type is abstract
  type.acos (val float.this.type) float.this.type is abstract
  type.atan (val float.this.type) float.this.type is abstract
  type.atan2 (y, x float.this.type) float.this.type is abstract


  # hyperbolicus

  type.sinh (val float.this.type) float.this.type is abstract
  type.cosh (val float.this.type) float.this.type is abstract
  type.tanh (val float.this.type) float.this.type is abstract


  # area hyperbolicus

  type.asinh(val float.this.type) float.this.type is
    # ln(x+sqrt(x^2+1))
    log (val + sqrt (val ** two + one))
  type.acosh(val float.this.type) float.this.type is
    # ln(x+sqrt(x^2-1))
    log (val + sqrt (val ** two - one))
  type.atanh(val float.this.type) float.this.type is
    # 1/2*ln((1+x)/(1-x))
    log ((one + val)/(one - val)) / two
