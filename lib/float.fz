# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature float
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# float -- floating point values
#
#
# float is the abstract parent of concrete floating point features such as
# f32 or f64.
#
float(redef F type : float F) : numeric F, floats F is


  # preconditions for basic operations: true if the operation's result is
  # representable for the given values.  For IEEE_754, all operations are
  # defined for all values.
  #
  redef prefix +! bool is true
  redef prefix -! bool is true
  redef infix +! (other F) bool is true
  redef infix -! (other F) bool is true
  redef infix *! (other F) bool is true
  redef infix /! (other F) bool is true
  redef infix %! (other F) bool is true
  redef infix **!(other F) bool is true


  # convert a float value to i64 dropping any fraction.
  # the value must be in the range of i64
  as_i64 i64 is abstract


  fract F is abstract


  # round floating point number
  # ties to away (0.5 => 1; -0.5 => -1; etc.)
  #
  # NYI this could be made faster, see here:
  # https://cs.opensource.google/go/go/+/refs/tags/go1.18.1:src/math/floor.go;l=79
  round F is
    if thiz < zero
      -(-thiz).round
    else if fract = zero
      thiz
    else
      (thiz + one/two).floor


  # floor: the greatest integer lower or equal to this
  floor F is
    if fract < zero
      thiz - fract - one
    else
      thiz - fract


  # ceiling: the smallest integer greater or equal to this
  ceil F is
    if fract ≤ zero
      thiz - fract
    else
      thiz - fract + one


  # number of bits used for mantissa,
  # including leading '1' that is not actually stored
  #
  type.significand_bits i32 is abstract

  # number of bits used for exponent
  #
  type.exponent_bits i32 is abstract


  # the amount of bits that are used to encode the mantissa
  type.mantissa_bits => significand_bits - 1


  # number of bytes required to store this value
  #
  type.bytes i32 is abstract


  # number of bits required to store this value
  #
  type.size => 8*bytes


  # eulers number 2.72..
  #
  type.ℇ float.this.type is abstract


  # pi 3.14...
  #
  type.π float.this.type is abstract


  # conversion
  #

  # convert an i64 value to a floating point value
  #
  # if the value cannot be represented exactly, the result is either
  # the nearest higher or nearest lower value
  #
  type.from_i64(val i64) float.this.type is abstract


  # hyperbolicus

  type.sinh (val float.this.type) float.this.type is abstract
  type.cosh (val float.this.type) float.this.type is abstract
  type.tanh (val float.this.type) float.this.type is abstract



# floats -- unit type defining features related to float but not requiring
# an instance
#
floats(F type : float F) : numerics F is


  exponent_range => -min_exp..max_exp

  # non signaling not a number
  quiet_NaN => zero / zero

  # not a number
  NaN => quiet_NaN

  # is not a number?
  is_NaN(val F) bool is abstract

  negative_infinity => -one / zero

  positive_infinity => one / zero

  # infinity
  infinity => positive_infinity

  min_exp i32 is abstract
  max_exp i32 is abstract
  min_positive F is abstract
  max F is abstract
  epsilon F is abstract


  square_root(val F) F is abstract
  # square root
  sqrt(val F) => square_root val



  # the `val`-th power of ℇ
  # i.e. ℇᵛᵃˡ
  #
  exp (val F) F is abstract


  # logarithm with base ℇ
  #
  log (val F) F is abstract


  # logarithm with base `base`
  #
  log (base, val F) F
  pre base > zero
  is
    (log val) / (log base)


  # trigonometric

  sin (val F) F is abstract
  cos (val F) F is abstract
  tan (val F) F is abstract
  asin(val F) F is abstract
  acos(val F) F is abstract
  atan(val F) F is abstract
  atan2(y F, x F) F is abstract


  # arcus hyperbolicus

  asinh(val F) F is
    # ln(x+sqrt(x^2+1))
    log (val + sqrt (val ** two + one))
  acosh(val F) F is
    # ln(x+sqrt(x^2-1))
    log (val + sqrt (val ** two - one))
  atanh(val F) F is
    # 1/2*ln((1+x)/(1-x))
    log ((one + val)/(one - val)) / two
