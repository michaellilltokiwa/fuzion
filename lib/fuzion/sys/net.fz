# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature fuzion.sys.net
#
# -----------------------------------------------------------------------

# groups networking related features
net is


  # create a new socket descriptor
  #
  # true  => arr_result[0] is the socket descriptor
  # false => arr_result[0] is an error number
  #
  socket(arr_result Any) bool is intrinsic

  # convenience wrapper for socket intrinsic
  socket outcome i64 is
    arr array i64 := [0]
    if socket arr.internalArray.data then arr[0] else error "socket open failed, error number: {arr[0]}"


  # bind server, zero on success
  # array data depends on the family.
  # - ipv4: first two bytes encode the port,
  #         then four bytes for the ip address
  #
  # returns zero on success, anything else is an error.
  #
  bind   (sd i64, family i32, arr_data Any, length i32) i32 is intrinsic


  # NYI wrap bind, listen, connect like this:
  # bind   (sd i64, family i32, arr_data Any, length i32) outcome unit is
  #   res := bind sd family arr_data length
  #   if res = 0 then unit else error "binding failed with error: $res."


  # activates the server socket, setting a backlog
  # for maximum amount of connections which are kept
  # waiting for acceptance.
  #
  # returns zero on success, anything else is an error.
  #
  listen (sd i64, backlog i32) i32 is intrinsic


  # accept a new connection for given socket.
  # blocks until there is a connection to accept.
  # returns a new / different descriptor which
  # corresponds to the accepted connection only.
  #
  # true  => arr_result[0] is the socket descriptor
  # false => arr_result[0] is an error number
  #
  accept (sd i64, arr_result Any) bool is intrinsic

  # convenience wrapper for accept intrinsic
  accept(sd i64) outcome i64 is
    arr array i64 := [0]
    if accept sd arr.internalArray.data then arr[0] else error "accept failed, error number: {arr[0]}"


  # connect the socket.
  # details depend on the used family:
  # - ipv4: first two bytes encode the port,
  #         then four bytes for the ip address
  #
  # returns zero on success, anything else is an error.
  #
  connect(sd i64, family i32, arr_data Any, length i32) i32 is intrinsic


  # read bytes into arr_data
  #
  # true  => arr_result[0] is the number of bytes read
  # false => arr_result[0] is an error number
  #
  read(sd i64, arr_data Any, length i32, arr_result Any) bool is intrinsic


  # reads a maximum of max_bytes from descriptor
  #
  read(descriptor i64, max_bytes i32) outcome (array u8) is
    buff := internal_array u8 max_bytes
    arr array i64 := [0]
    if net.read descriptor buff.data max_bytes arr.internalArray.data
      # NYI there should be a way to use a slice of internalArray to init array
      array u8 arr[0].as_i32 (idx -> buff[idx])
    else
      error "error: {arr[0]}"


  # write buffer bytes on socket
  #
  # returns zero on success, anything else is an error.
  #
  write(sd i64, arr_data Any, length i32) i32 is intrinsic


  # write data to descriptor
  write(descriptor i64, data array u8) outcome unit is
    res := net.write descriptor data.internalArray.data data.length
    if res = -1 then error "error: $res" else unit


  # close socket
  #
  # returns zero on success, anything else is an error.
  #
  close0(sd i64) i32 is intrinsic


  # close descriptor
  close(sd i64) outcome unit is
    res := close0 sd
    if res = -1 then error "error: $res" else unit


  # NYI these numbers are system dependent

  tcp is
  udp is
  local is
  ipv4 is
  ipv6 is
  stream is
  raw is


  protocols : choice ipv4 tcp udp ipv6 is
    num i32 is
      match protocols.this
        ipv4 => 0
        tcp => 6
        udp => 17
        ipv6 => 41

  family : choice local ipv4 ipv6 is
    num i32 is
      match family.this
        local => 1  # pipes etc.
        ipv4  => 2
        ipv6  => 10

  socket_type : choice net.stream raw is
    num i32 is
      match socket_type.this
        stream net.stream => 2
        raw raw => 3



  # NYI we probably want to hold more than one connection per thread?
  # use type arg to identify connection effect like in mut
  private connection(desc outcome i64, m effectMode.val) : effect m is

    # get the last error that occured
    last_error => desc.bind unit (_ -> unit)

    # is this connection still active?
    is_active => desc.ok

    replace(T type, a T) T is
      replace
      a

    # read bytes from connection
    public read(max_bytes i32) outcome (array u8) is
      # close connection on certain read errors?
      replace (match desc
        d i64 => read d max_bytes
        e error => e)

    # NYI when to stop reading?
    public read outcome String is
      # read buffer in bytes
      buffer_size i32 := 10

      match desc
        d i64 =>
          l := (1..)
            .reduce((list u8), (lists.empty u8), ((r,_) ->
              match read buffer_size
                e error => abort r
                a array u8 => r ++ a))
          String.type.from_bytes l
        e error =>
          e

    public write(data Sequence u8) outcome unit is
      # close connection on certain write errors?
      match desc
        d i64 => replace (write d data.as_array)
        e error => e

    close is
      match desc
        d i64 =>
          match close d
            unit =>
            e error =>
              connection e effectMode.repl
        * =>
      unit


  # short hand to get current connection
  # NYI type parameter to identify different connections
  connection =>
    if !effects.exists connection
      connection (error "not initialized") effectMode.default
    connection.env



  # establish a new connection
  # any active connection will be closed
  # this call may block until connection is establised.
  # NYI blocking / none blocking
  #
  client(addr Sequence u8, port u16)
  pre  (addr.count = 32/8   # ipv4
     || addr.count = 128/8) # ipv6
  is

    connection.close

    family_of(addr Sequence u8) family is
      if addr.count = 32/8 then ipv4 else ipv6

    # open socket
    match socket
      sd i64 =>
        port_addr array u8 := (port.as_bytes ++ addr).as_array
        # connect to addr, port
        res := connect sd (family_of addr).num port_addr.internalArray.data port_addr.length
        if res != 0
          close sd
          connection (error "connecting client socket to addr {addr} port $port failed with error {res}.") effectMode.repl
        else
          connection sd effectMode.repl
      con_err error =>
        connection con_err effectMode.repl
    unit


  private server(
    p Server_Provider,
    m effectMode.val,
    _ unit
  ) : effect m
  is

    desc := p.initialize

    # get the last error that occured
    last_error => desc.bind unit (_ -> unit)

    # is the server running?
    is_active => desc.ok

    # close server, stop listening on port
    close is
      match desc
        d i64 =>
          match close d
            unit =>
              server (default_server_provider (error "not initialized")) effectMode.repl unit
            error error =>
              server (default_server_provider error) effectMode.repl unit
        * =>
      unit


    # close current connection
    # accept new connection
    # blocks until connection is established
    accept is
      connection.close
      match desc
        d i64 =>
          connection (accept d) effectMode.repl
        * =>
      unit


  # open new server on port
  # closes currently installed server
  # NYI blocking / none blocking
  server(f family, port u16) =>
    server.close
    server (ip_server_provider f port) effectMode.repl unit


  # get currently installed server from env
  server =>
    if !effects.exists server
      server (default_server_provider (error "not initialized")) effectMode.default unit
    server.env


  Server_Provider ref is
    initialize outcome i64 is abstract


  ip_server_provider(f family, port u16) : Server_Provider is
    # opens sockets, binds to port and sets socket to listening
    initialize outcome i64 is
      backlog := 10
      # open socket
      match socket
        sd i64 =>
          port_addr array u8:= (port.as_bytes ++ [u8 0, u8 0, u8 0, u8 0]).as_array
          # bind to port
          res := bind sd f.num port_addr.internalArray.data port_addr.length
          if res != 0
            close sd
            error "binding server socket to port $port failed with error $res."
          else
            # listen
            res := listen sd backlog
            if res != 0
              close sd
              error "listening on socket failed with error $res."
            else
              sd
        con_err error => con_err


  default_server_provider(e error) : Server_Provider is
    initialize outcome i64 is
      e
