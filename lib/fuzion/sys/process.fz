# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature fuzion.sys.process
#
# -----------------------------------------------------------------------

# fuzion.sys.process -- unit type grouping routines related to process
#
public process is


  # how many bytes are written at a time
  # POSIX.1 requires PIPE_BUF to be at least 512 bytes
  private write_chunk_size := 512

  # how many bytes are read at a time
  # POSIX.1 requires PIPE_BUF to be at least 512 bytes
  private read_chunk_size := 512


  # NYI compose processes

  # NYI args, env, pwd
  # NYI cleanup after process exit
  create(args Any, arg_len i32, env_vars Any, env_vars_len i32, r Any, args_str Any, env_str Any) i32 is intrinsic


  #
  wait(p i64) u32 is intrinsic

  # send_signal(p i64, signal i32) NYI is intrinsic
  # is_alive(p i64) NYI is intrinsic
  # exit_code(p i64) NYI is intrinsic

  # NYI move this to effect
  # NYI rename
  private r_process(private p_id, stdin, stdout, stderr i64) ref
  is

    say "created process $p_id, {r_process.this.stdin}, {r_process.this.stdout}, {r_process.this.stderr}"


    close =>
      say "closing {r_process.this.stdin}"
      say "closed {r_process.this.stdin} {pipe.close r_process.this.stdin}"

    close_stdout =>
      say "closing {r_process.this.stdout} {r_process.this.stderr}"
      say "closed {r_process.this.stdout} {pipe.close r_process.this.stdout}"
      say "closed {r_process.this.stderr} {pipe.close r_process.this.stderr}"


    # wait for the process to end
    #
    exit =>
      say "waiting for $p_id"
      r := wait p_id
      say "exited $p_id with $r"
      r


    # write string to stdin of child process
    #
    write_string (s String) outcome i32 is
      write_bytes s.utf8


    # write bytes to stdin of child process
    #
    write_bytes (bytes Sequence u8) outcome i32
    pre bytes.count > 0
    is
      say "writing bytes to {r_process.this.stdin}"
      r := bytes
        .chunk write_chunk_size
        .reduce_or_error 0 ((r, t) ->
          arr := t.as_array
          bw := pipe.write r_process.this.stdin arr.internalArray.data arr.count
          if bw = -1
            abort (outcome i32) (error "error while writing. wrote $r bytes already.")
          else
            r+bw
        )
      say "finished writing bytes to {r_process.this.stdin} {r}"
      r


    # read `count` bytes
    #
    read_bytes (count i32) outcome (Sequence u8)
    pre count > 0
    is
      say "reading $count bytes from {r_process.this.p_id} {r_process.this.stdout}"
      arr := array u8 count i->0
      res := pipe.read r_process.this.stdout arr.internalArray.data arr.count
      if res = -1
        error "error reading from stdout."
      else
        say "bytes read from {r_process.this.stdout} count {res}"
        arr.slice 0 res


    # read all of stdout to string
    # NYI return error on error
    #
    read_string outcome String is
      arr := (for acc := (marray (Sequence u8)).type.new 0 (Sequence u8).type.empty, acc.add res.val
                  res := read_bytes read_chunk_size, read_bytes read_chunk_size
              while res.ok
              else
                acc)
      ref : String
        utf8 Sequence u8 is
          arr.flat_map_sequence u8 (x -> x)


    # NYI
    # read_string_safe String is
    #   ref : String
    #     utf8 Sequence u8 is



    # NYI cleanup resources (process handle windows, close pipes)

  r_processes (processes Sequence r_process)
  pre !processes.is_empty
  is
    # the output as a String
    redef as_string String is
      processes.last.read_string.as_string


    read_bytes (count i32) outcome (Sequence u8)
    pre count > 0
    is
      processes.last.read_bytes count


    write_bytes (bytes Sequence u8) outcome i32
    pre bytes.count > 0
    is
      processes.first.write_bytes bytes

    # close_stdout =>
    #   processes
    #     .for_each (p ->
    #       _ := p.close_stdout)


    exit Sequence u32 is
      processes
        .map_sequence (p ->
          p.close
          p.exit)




  processes_or_error : choice fuzion.sys.process.r_processes error is

    # pipe output to other process
    # NYI should wire pipe directly to process
    # NYI this works only when pipes buffer is large enough for
    # what is being written/read to/from pipes
    infix | (lp2 Lazy processes_or_error) processes_or_error is
      match processes_or_error.this
        p1 fuzion.sys.process.r_processes =>
          match lp2()
            p2 fuzion.sys.process.r_processes =>
              r :=  fuzion.sys.process.r_processes (p1.processes.concat_sequences p2.processes)
              concur.thread.spawn ()->
                for i in 1..1
                    p1rb := (p1.read_bytes fuzion.sys.process.read_chunk_size), (p1.read_bytes fuzion.sys.process.read_chunk_size)
                while p1rb.ok && (p2.write_bytes p1rb.val).ok
                # p1.close_stdout
                say "transfer tread finished"
              r

            e error =>
              e
        e error =>
          e


    # # the output as a String
    # redef as_string String is
    #   match processes_or_error.this
    #     r fuzion.sys.process.r_processes =>
    #       r.as_string
    #     error =>
    #       "*** error ***"



  # create process with option to pass environment variables
  #
  # NYI env_vars should be map, issue #1313
  create(process_and_args array String, env_vars array String) processes_or_error
  pre process_and_args.length > 0,
  # NYI allow utf-8?
      process_and_args ∀ (x -> x.as_codepoint_sequence ∀ (y -> y.is_ascii)),
      create.this.env_vars ∀ (x -> x.as_codepoint_sequence ∀ (y -> y.is_ascii)),
      create.this.env_vars ∀ (x -> x.contains "=") # NYI check that only one =
  is
    # posix_spawn needs last arg to be NULL
    arg_data := array Any process_and_args.count+1 (i -> if i<process_and_args.length then c_string process_and_args[i] else Any)

    # posix_spawn needs last arg to be NULL
    # NYI issue #1313
    # env_var_items := create.this.env_vars.items.as_array
    # env_data := array Any env_var_items.length+1 (i -> if i<env_var_items.length then "{env_var_items[i].values.0}={env_var_items[i].values.1}" else Any)
    env_data := array Any create.this.env_vars.length+1 (i -> if i<create.this.env_vars.length then c_string create.this.env_vars[i] else Any)

    res_data := array i64 4 i->0

    args_str := c_string (String.type.join process_and_args " ")
    env_str := c_string ((String.type.join create.this.env_vars (codepoint 0)) + (codepoint 0))

    if (create arg_data.internalArray.data arg_data.count env_data.internalArray.data env_data.count res_data.internalArray.data args_str env_str) = -1
      error "*** error creating process ***"
    else
      fuzion.sys.process.r_processes [fuzion.sys.process.r_process res_data[0] res_data[1] res_data[2] res_data[3]]



  # short hand to create process
  #
  create(process_and_args array String) =>
    e array String := []
    create process_and_args e
