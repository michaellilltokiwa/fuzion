# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature fuzion.sys.process
#
# -----------------------------------------------------------------------

# fuzion.sys.process -- unit type grouping routines related to process
#
public process is


  # how many bytes are written at a time
  # POSIX.1 requires PIPE_BUF to be at least 512 bytes
  private write_chunk_size := 512

  # how many bytes are read at a time
  # POSIX.1 requires PIPE_BUF to be at least 512 bytes
  private read_chunk_size := 512


  # NYI compose processes

  # NYI args, env, pwd
  # NYI cleanup after process exit
  create(args Any, arg_len i32, env_vars Any, env_vars_len i32, r Any, args_str Any, env_str Any) i32 is intrinsic


  #
  wait(p i64) u32 is intrinsic

  # send_signal(p i64, signal i32) NYI is intrinsic
  # is_alive(p i64) NYI is intrinsic
  # exit_code(p i64) NYI is intrinsic

  # NYI move this to effect
  # NYI rename
  private r_process(private p_id, stdin, stdout, stderr i64)
  is


    # close stdin of child process
    #
    close_write bool is
      pipe.close r_process.this.stdin = 0


    # wait for the process to end
    #
    exit =>
      r := wait p_id
      pipe.close r_process.this.stdout
      pipe.close r_process.this.stderr
      r


    # write string to stdin of child process
    #
    write_string (s String) outcome i32 is
      write_bytes s.utf8


    # write bytes to stdin of child process
    #
    write_bytes (bytes Sequence u8) outcome i32
    pre bytes.count > 0
    is
      bytes
        .chunk write_chunk_size
        .reduce_or_error 0 ((r, t) ->
          arr := t.as_array
          bw := pipe.write r_process.this.stdin arr.internalArray.data arr.count
          if bw = -1
            abort (outcome i32) (error "error while writing. wrote $r bytes already.")
          else
            r+bw
        )


    # read `count` bytes
    #
    read_bytes (count i32) choice error io.end_of_file (Sequence u8)
    pre count > 0
    is
      arr := array u8 count i->0
      res := pipe.read r_process.this.stdout arr.internalArray.data arr.count
      if res = -1
        error "error reading from stdout."
      else if res = 0
        io.end_of_file
      else
        arr.slice 0 res


    # read all of stdout to string
    # NYI return error on error
    #
    read_string outcome String is
      (arr, last_read) :=
        for acc := (marray (Sequence u8)).type.new 0 (Sequence u8).type.empty,
            acc.add (match res
                        s Sequence u8 => s
                        * => panic "illegal state")
            res := read_bytes read_chunk_size, read_bytes read_chunk_size
        while
          match res
            Sequence => true
            * => false
        else
          (acc, res)

      match last_read
        io.end_of_file =>
          ref : String
            utf8 Sequence u8 is
              arr.flat_map_sequence u8 (x -> x)
        e error => e
        Sequence => panic "illegal"


    # NYI
    # read_string_safe String is
    #   ref : String
    #     utf8 Sequence u8 is



    # NYI cleanup resources (process handle windows, close pipes)

  r_processes (processes Sequence r_process)
  pre !processes.is_empty
  is
    # the output as a String
    redef as_string String is
      processes.last.read_string.as_string


    read_bytes (count i32) choice error io.end_of_file (Sequence u8)
    pre count > 0
    is
      processes.last.read_bytes count


    read_string outcome String is
      processes.last.read_string


    write_bytes (bytes Sequence u8) outcome i32
    pre bytes.count > 0
    is
      processes.first.write_bytes bytes


    # write string to stdin of child process
    #
    write_string (s String) outcome i32 is
      write_bytes s.utf8


    close_write =>
      processes.first.close_write




    exit Sequence u32 is
      processes
        .map_sequence (p ->
          p.exit)




  processes_or_error : choice fuzion.sys.process.r_processes error is

    # pipe output to other process
    # NYI should wire pipe directly to process
    # NYI this works only when pipes buffer is large enough for
    # what is being written/read to/from pipes
    infix | (lp2 Lazy processes_or_error) processes_or_error is
      match processes_or_error.this
        p1 fuzion.sys.process.r_processes =>
          match lp2()
            p2 fuzion.sys.process.r_processes =>
              r :=  fuzion.sys.process.r_processes (p1.processes.concat_sequences p2.processes)

              # thread to pipe from one process to other
              concur.thread.spawn ()->
                for p1rb := (p1.read_bytes fuzion.sys.process.read_chunk_size), (p1.read_bytes fuzion.sys.process.read_chunk_size)
                while
                  match p1rb
                    s Sequence u8 => (p2.write_bytes s).ok
                    * => false
                _ := p2.close_write

              r

            e error =>
              e
        e error =>
          e


    # the output as a String
    redef as_string String is
      match processes_or_error.this
        r fuzion.sys.process.r_processes =>
          r.as_string
        error =>
          "*** error ***"



  # short hand to create process
  #
  create(process_and_args array String) =>
    e array String := []
    create process_and_args e
