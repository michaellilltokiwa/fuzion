# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature fuzion.sys.process
#
# -----------------------------------------------------------------------

# fuzion.sys.process -- unit type grouping routines related to process
#
public process is


  # NYI compose processes

  # NYI args, env, pwd
  # NYI cleanup after process exit
  create(args Any, arg_len i32, env_vars Any, env_vars_len i32, r Any, args_str Any, env_str Any) i32 is intrinsic
  wait(p i64) is intrinsic
  # send_signal(p i64, signal i32) NYI is intrinsic
  # is_alive(p i64) NYI is intrinsic
  # exit_code(p i64) NYI is intrinsic

  # NYI move this to effect
  # NYI rename
  r_process(private p_id, stdin, stdout, stderr i64) is
    wait =>
      wait p_id

    close_write bool is
      pipe.close r_process.this.stdin = 0

    write(s String) outcome unit is
      arr := s.utf8.as_array
      res := pipe.write r_process.this.stdin arr.internalArray.data arr.count
      if res != arr.count
        error "error writing to stdin."
      else
        unit

    read(count i32) outcome String is
      arr := array u8 count i->0
      res := pipe.read r_process.this.stdout arr.internalArray.data arr.count
      if res = -1
        error "error reading from stdout."
      else
        String.type.from_bytes (array u8 res i->arr[i])


    # NYI cleanup resources

  # NYI env_vars should be map, issue #1313
  create(process_and_args array String, env_vars array String) outcome r_process
  pre process_and_args.length > 0,
  # NYI allow utf-8?
      process_and_args ∀ (x -> x.as_codepoint_sequence ∀ (y -> y.is_ascii)),
      create.this.env_vars ∀ (x -> x.as_codepoint_sequence ∀ (y -> y.is_ascii)),
      create.this.env_vars ∀ (x -> x.contains "=") # NYI check that only one =
  is
    # posix_spawn needs last arg to be NULL
    arg_data := array Any process_and_args.count+1 (i -> if i<process_and_args.length then c_string process_and_args[i] else Any)

    # posix_spawn needs last arg to be NULL
    # NYI issue #1313
    # env_var_items := create.this.env_vars.items.as_array
    # env_data := array Any env_var_items.length+1 (i -> if i<env_var_items.length then "{env_var_items[i].values.0}={env_var_items[i].values.1}" else Any)
    env_data := array Any create.this.env_vars.length+1 (i -> if i<create.this.env_vars.length then c_string create.this.env_vars[i] else Any)

    res_data := array i64 4 i->0

    args_str := c_string (String.type.join process_and_args " ")
    env_str := c_string ((String.type.join create.this.env_vars (codepoint 0)) + (codepoint 0))

    if (create arg_data.internalArray.data arg_data.count env_data.internalArray.data env_data.count res_data.internalArray.data args_str env_str) = -1
      error "error creating process"
    else
      r_process res_data[0] res_data[1] res_data[2] res_data[3]

