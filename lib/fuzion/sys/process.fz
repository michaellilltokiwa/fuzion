# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature fuzion.sys.process
#
# -----------------------------------------------------------------------

# fuzion.sys.process -- unit type grouping routines related to process
#
public process is


  # how many bytes are written at a time
  # NYI put this in effect?
  private write_chunk_size := 100

  # how many bytes are read at a time
  # NYI put this in effect?
  private read_chunk_size := 100


  # NYI compose processes

  # NYI args, env, pwd
  # NYI cleanup after process exit
  create(args Any, arg_len i32, env_vars Any, env_vars_len i32, r Any, args_str Any, env_str Any) i32 is intrinsic
  wait(p i64) i32 is intrinsic

  # send_signal(p i64, signal i32) NYI is intrinsic
  # is_alive(p i64) NYI is intrinsic
  # exit_code(p i64) NYI is intrinsic

  # NYI move this to effect
  # NYI rename
  r_process(private p_id, stdin, stdout, stderr i64) is


    # wait for the process to end
    wait =>
      wait p_id


    # close stdin of child process
    #
    close_write bool is
      pipe.close r_process.this.stdin = 0


    # write string to stdin of child process
    #
    write_string (s String) outcome unit is
      write_bytes s.utf8


    # write bytes to stdin of child process
    #
    write_bytes (b Sequence u8) outcome unit is
      for chunk in b.chunk write_chunk_size do
        arr := chunk.as_array
        res := pipe.write r_process.this.stdin arr.internalArray.data arr.count
        if res != arr.count
          error "error writing to stdin."
        else
          unit


    # read `count` bytes
    #
    read_bytes (count i32) outcome (Sequence u8) is
      arr := array u8 count i->0
      res := pipe.read r_process.this.stdout arr.internalArray.data arr.count
      if res = -1
        error "error reading from stdout."
      else
        arr.slice 0 res


    # read all of stdout to string
    # NYI return error on error
    #
    read_string outcome String is
      arr := (for acc := (marray (Sequence u8)).type.new 0 (Sequence u8).type.empty, acc.add res.val
                  res := read_bytes read_chunk_size, read_bytes read_chunk_size
              while res.ok && !res.val.is_empty
              else
                acc)
      ref : String
        utf8 Sequence u8 is
          arr.flat_map_sequence u8 (x -> x)


    # NYI
    # read_string_safe String is
    #   ref : String
    #     utf8 Sequence u8 is



    # NYI cleanup resources (process handle windows, close pipes)


  process_or_error : choice r_process error is

    # pipe output to other process
    # NYI should wire pipe directly to process
    # NYI this works only when pipes buffer is large enough for
    # what is being written/read to/from pipes
    infix | (p2 Lazy process_or_error) process_or_error is
      match process_or_error.this
        p1 r_process =>
          p3 := p2()
          match p3
            p4 r_process =>
              for p1rb := (p1.read_bytes fuzion.sys.process.read_chunk_size), (p1.read_bytes fuzion.sys.process.read_chunk_size)
              while p1rb.ok && !p1rb.val.is_empty && (p4.write_bytes p1rb.val).ok
              p4.close_write

              exit_code_p1 := p1.wait
              if exit_code_p1 = 0
                p3
              else
                error "*** exit_code: $exit_code_p1 ***"
            e error =>
              e
        e error =>
          e

    # the output as a String
    redef as_string String is
      match process_or_error.this
        r r_process =>
          r.read_string.val ""
        error => "*** error ***"



  # create process with option to pass environment variables
  #
  # NYI env_vars should be map, issue #1313
  create(process_and_args array String, env_vars array String) process_or_error
  pre process_and_args.length > 0,
  # NYI allow utf-8?
      process_and_args ∀ (x -> x.as_codepoint_sequence ∀ (y -> y.is_ascii)),
      create.this.env_vars ∀ (x -> x.as_codepoint_sequence ∀ (y -> y.is_ascii)),
      create.this.env_vars ∀ (x -> x.contains "=") # NYI check that only one =
  is
    # posix_spawn needs last arg to be NULL
    arg_data := array Any process_and_args.count+1 (i -> if i<process_and_args.length then c_string process_and_args[i] else Any)

    # posix_spawn needs last arg to be NULL
    # NYI issue #1313
    # env_var_items := create.this.env_vars.items.as_array
    # env_data := array Any env_var_items.length+1 (i -> if i<env_var_items.length then "{env_var_items[i].values.0}={env_var_items[i].values.1}" else Any)
    env_data := array Any create.this.env_vars.length+1 (i -> if i<create.this.env_vars.length then c_string create.this.env_vars[i] else Any)

    res_data := array i64 4 i->0

    args_str := c_string (String.type.join process_and_args " ")
    env_str := c_string ((String.type.join create.this.env_vars (codepoint 0)) + (codepoint 0))

    if (create arg_data.internalArray.data arg_data.count env_data.internalArray.data env_data.count res_data.internalArray.data args_str env_str) = -1
      error "*** error creating process ***"
    else
      r_process res_data[0] res_data[1] res_data[2] res_data[3]



  # short hand to create process
  #
  create(process_and_args array String) =>
    e array String := []
    create process_and_args e
