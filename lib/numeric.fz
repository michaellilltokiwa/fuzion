# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature numeric
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# numeric -- parent of all numeric features
#
numeric : has_hash, has_total_order is

  # get numeric.this value of type T.  This is used for a generic implemention
  # of some features (e.g. prefix -, abs)
  thiz numeric.this.type is numeric.this

  is_zero => numeric.this = numeric.this.type.zero
  is_one  => numeric.this = numeric.this.type.one

  # basic operations: 'prefix +' (identity)
  prefix + numeric.this.type
    pre
      safety: +!thiz
  is thiz

  # basic operations: 'prefix -' (negation)
  prefix - numeric.this.type
    pre
      safety: -!thiz
  is numeric.this.type.zero - thiz

  # basic operations: 'infix +' (addition)
  infix +  (other numeric.this.type) numeric.this.type
    pre
      safety: thiz +! other
  is abstract

  # basic operations: 'infix -' (subtraction)
  infix -  (other numeric.this.type) numeric.this.type
    pre
      safety: thiz -! other
  is abstract

  # basic operations: 'infix *' (multiplication)
  infix *  (other numeric.this.type) numeric.this.type
    pre
      safety: thiz *! other
  is abstract

  # basic operations: 'infix /' (division)
  infix /  (other numeric.this.type) numeric.this.type
    pre
      safety: thiz /! other,
      safety: other != numeric.this.type.zero
  is abstract

  # basic operations: 'infix %' (division remainder)
  infix %  (other numeric.this.type) numeric.this.type
    pre
      safety: thiz %! other,
      safety: other != numeric.this.type.zero
  is abstract

  # basic operations: 'infix **' (exponentiation)
  infix ** (other numeric.this.type) numeric.this.type
    pre
      safety: thiz **! other,
      safety: other ≥ numeric.this.type.zero
  is abstract


  # preconditions for basic operations: true if the operation's result is
  # representable for the given values
  #
  # This does not check if the operation is defined (i.e, it
  # returns true for '3/!0' or '0**!0'.
  #
  prefix +! bool is true
  prefix -! bool is abstract
  infix +! (other numeric.this.type) bool is abstract
  infix -! (other numeric.this.type) bool is abstract
  infix *! (other numeric.this.type) bool is abstract
  infix /! (other numeric.this.type) bool is abstract
  infix %! (other numeric.this.type) bool is abstract
  infix **!(other numeric.this.type) bool is abstract


  # overflow checking operations
  prefix -? num_option numeric.this.type is - thiz
  infix +? (other numeric.this.type) num_option numeric.this.type is thiz + other
  infix -? (other numeric.this.type) num_option numeric.this.type is thiz - other
  infix *? (other numeric.this.type) num_option numeric.this.type is thiz * other
  infix **?(other numeric.this.type) num_option numeric.this.type is abstract

  # saturating  operations
  prefix -^  numeric.this.type is - thiz
  infix +^ (other numeric.this.type) numeric.this.type is thiz + other
  infix -^ (other numeric.this.type) numeric.this.type is thiz - other
  infix *^ (other numeric.this.type) numeric.this.type is thiz * other
  infix **^(other numeric.this.type) numeric.this.type is abstract


  sign => if numeric.this = numeric.this.type.zero then 0 else if numeric.this > numeric.this.type.zero then 1 else -1

  abs => if sign ≥ 0 then thiz else -thiz


  # the u32 value corresponding to this
  # note: potential fraction will be discarded
  # NYI replace this by as_u32?
  to_u32 u32
    pre
      debug: numeric.this ≥ numeric.this.type.zero
  is
    if (numeric.this ≥ numeric.this.type.one) ((thiz - numeric.this.type.one).to_u32 + 1)
    else 0


  # this numeric value as an u8
  as_u8 u8
    pre
      debug: numeric.this ≥ numeric.this.type.zero
  is abstract


  # find the highest power of b that is less or equal than thiz.
  #
  private highest(b numeric.this.type) numeric.this.type
    pre
      debug: thiz.sign ≥ 0
    post
      debug: (numeric.this = numeric.this.type.zero: result = numeric.this.type.one),
      debug: (numeric.this != numeric.this.type.zero: thiz / b < result ≤ thiz)
  # NYI: original postcondition code should cause a compiler error since
  # result.infix <= expects an argument of type T while integer.this is
  # not of type T.
  #
  #     integer.this != zero: integer.this / b < result <= integer.this
  is
    for
      bs := numeric.this.type.one, bs * b
    while thiz / b ≥ bs


  # is this part of given set
  #
  # NYI: infix operators currently always use dynamic binding on the lhs and pass
  # the rhs as an argument.  If we would support an 'rinfix ∈' that would use the
  # rhs for dynamic binding and the lhs as argument, we could define '∈' in Set T
  # and it would work for all set types.
  #
  element_of(s container.Set numeric.this.type) => s.contains thiz
  infix ∈ (s container.Set numeric.this.type) => numeric.this.element_of s


  # is this not part of given set
  #
  not_element_of(s container.Set numeric.this.type) => !element_of s
  infix ∉ (s container.Set numeric.this.type) => numeric.this.not_element_of s


  # -----------------------------------------------------------------------
  #
  # type features:


  # identity element for 'infix +'
  #
  type.zero numeric.this.type is abstract


  # identity element for 'infix *'
  #
  type.one  numeric.this.type is abstract


  # the value corresponding to v in whatever integer implementation we have,
  # maximum in case of overflow
  #
  # NOTE: this is marked 'dyn' to get an implementation for all heirs for numeric
  #
  type.from_u32(v u32) numeric.this.type is
    if v = (u32 0) zero else (from_u32 v-1) +^ one


  # the constant '2' in whatever integer implementation we have, maximum in case of overflow
  #
  type.two => from_u32(2)


  # the constant '10' in whatever integer implementation we have, maximum in case of overflow
  #
  type.ten => from_u32(10)


  # equality
  #
  type.equality(a, b numeric.this.type) bool is abstract


  # total order
  #
  type.lteq(a, b numeric.this.type) bool is abstract


  # monoid of numeric with infix + operation.  Will create sum of all elements it
  # is applied to.
  #
  type.sum : Monoid numeric.this.type is
    redef infix ∙ (a, b numeric.this.type) => a + b
    redef e => zero


  # monoid of numeric with infix * operation.  Will create product of all elements
  # it is applied to.
  #
  type.product : Monoid numeric.this.type is
    redef infix ∙ (a, b numeric.this.type) => a * b
    redef e => one


  # monoid of numeric with infix +^ operation.  Will create sum of all elements it
  # is applied to, stopping at max/min value in case of overflow.
  #
  type.sum_saturating : Monoid numeric.this.type is
    redef infix ∙ (a, b numeric.this.type) => a +^ b
    redef e => zero


  # monoid of numeric with infix *^ operation.  Will create product of all elements
  # it is applied to, stopping at max/min value in case of overflow.
  #
  type.product_saturating : Monoid numeric.this.type is
    redef infix ∙ (a, b numeric.this.type) => a *^ b
    redef e => one
