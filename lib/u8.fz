# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature u8
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# u8 -- 8-bit unsigned integer values
#
public u8(public val u8) : num.wrap_around, has_interval is

  # overflow checking

  # would negation cause an overflow?
  redef wrapped_on_neg => !is_zero

  # would addition + other cause an overflow or underflow?
  public fixed overflow_on_add (other u8) => u8.max -° val < other
  public fixed underflow_on_add(other u8) => false

  # would subtraction - other cause an overflow or underflow?
  public fixed overflow_on_sub (other u8) => false
  public fixed underflow_on_sub(other u8) => val < other

  # would multiplication * other cause an overflow or underflow?
  public fixed overflow_on_mul (other u8) => as_i32 *° other.as_i32 > u8.max.as_i32
  public fixed underflow_on_mul(other u8) => false

  # neg, add, sub, mul with wrap-around semantics
  public fixed prefix -° u8 => intrinsic
  public fixed infix +° (other u8) u8 => intrinsic
  public fixed infix -° (other u8) u8 => intrinsic
  public fixed infix *° (other u8) u8 => intrinsic

  # division and remainder with check for div-by-zero
  public fixed infix / (other u8) => div other
  public fixed infix % (other u8) => mod other

  # division and remainder with crash in case of div-by-zero
  div (other u8) u8 => intrinsic
  mod (other u8) u8 => intrinsic

  # bitwise and, or and xor operations
  public fixed infix &  (other u8) u8 => intrinsic
  public fixed infix |  (other u8) u8 => intrinsic
  public fixed infix ^  (other u8) u8 => intrinsic

  # shift operations (unsigned)
  public fixed infix >> (other u8) u8 => intrinsic
  public fixed infix << (other u8) u8 => intrinsic

  public as_i8 i8
    pre
      debug: val ≤ i8.max.as_u8
    =>
      cast_to_i8
  public as_i16 => as_i32.as_i16
  public as_i32 i32 => intrinsic
  public as_i64  => as_i32.as_i64
# as_i128 => as_i32.as_i128
  public as_u8   => val
  public as_u16  => as_i32.as_u16
  public as_u32  => as_i32.as_u32
  public as_u64  => as_i32.as_u64
  public as_u128 => as_i32.as_u128
  public as_int  => int as_i64

  public cast_to_i8 i8 => intrinsic


  # create hash code from this number
  public type.hash_code(a u8.this) u64 =>
    hash a.as_u64


  # find the highest 1 bit in this integer and return integer with
  # this single bit set or 0 if this is 0.
  #
  public highest_one_bit u8 =>
    (v, s) := (val, u8 0)
    (v, s) := if (v < u8 0x10) (v, s) else (v >> 4, s + 4)
    (v, s) := if (v <    u8 4) (v, s) else (v >> 2, s + 2)
    (v, s) := if (v <    u8 2) (v, s) else (v >> 1, s + 1)
    v << s


  # count the number of trailing zeros in this integer.
  #
  public trailing_zeros i32 =>
    (v, s) := (val, 0)
    (v, s) := if (v & 0xf) != u8 0 then (v, s) else (v >> 4, s + 4)
    (v, s) := if (v &   3) != u8 0 then (v, s) else (v >> 2, s + 2)
    (v, s) := if (v &   1) != u8 0 then (v, s) else (v >> 1, s + 1)
    if           (v &   1) != u8 0 then     s  else               8


  # count the number of 1 bits in the binary representation of this
  # integer.
  #
  public ones_count i32 =>
    v := val.as_i32
    m := v & 0xaa; v := v - m + (m >> 1)
    m := v & 0xcc; v := v - m + (m >> 2)
    m := v & 0xf0; v := v - m + (m >> 4)
    v


  # the least significant byte of this integer
  public low8bits u8 => val



  # is this u8 an ASCII white-space character?
  #
  public is_ascii_white_space =>
    (val = (u8  9) ||  // HT
     val = (u8 10) ||  // LF
     val = (u8 11) ||  // VT
     val = (u8 12) ||  // FF
     val = (u8 13) ||  // CR
     val = (u8 32)     // SPACE
    )



  # -----------------------------------------------------------------------
  #
  # type features:


  # identity element for 'infix +'
  #
  fixed type.zero u8  => 0


  # identity element for 'infix *'
  #
  fixed type.one  u8  => 1


  # equality
  #
  fixed type.equality(a, b u8) bool => intrinsic_constructor


  # total order
  #
  fixed type.lteq(a, b u8) bool => intrinsic_constructor


  # returns the number in whose bit representation all bits are ones
  fixed type.all_bits_set => u8 0xff


  # minimum
  #
  public fixed type.min => u8 0


  # maximum
  #
  public fixed type.max => u8 0xff
