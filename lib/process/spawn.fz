# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature process.spawn
#
# -----------------------------------------------------------------------

private:public spawned(h process.Default_Handler /* NYI should be Handler. can not inherit (pipe T)*/) : simple_effect
is

  # how many bytes are read at a time
  # POSIX.1 requires PIPE_BUF to be at least 512 bytes
  # NYI move this to effect?
  private read_chunk_size := 512

  public read_bytes(count i32) choice (array u8) io.end_of_file error is
    h.read_bytes count

  public write_bytes(bytes Sequence u8) outcome i32 is
    h.write_bytes bytes

  # read up to n bytes of stdout to string
  #
  public read_string(n i32) outcome String is

    rp :=
      ref : io.Read_Provider
        read(count i32) choice (array u8) io.end_of_file error is
          h.read_bytes count

    (io.buffered.reader rp read_chunk_size [])
      .with (()->io.buffered.read_string n)

  # read string, up to 1MB from stdout
  public read_string outcome String is
    read_string 1E9



  # write string to stdin of child process
  #
  public write_string (s String) outcome i32 is
    h.write_bytes s.utf8

  public close_write =>
    h.close_write

  public exit_code =>
    h.exit_code


  public pipe_to (T type, process_and_args array String, code () -> T) outcome T is
    h.pipe_to process_and_args (container.ordered_map String String).type.empty code

  public pipe_to (T type, process_and_args array String, env_vars container.Map String String, code () -> T) outcome T is
    h.pipe_to process_and_args env_vars code



Handler ref is
  read_bytes(count i32) choice (array u8) io.end_of_file error is abstract
  write_bytes(bytes Sequence u8) outcome i32 is abstract
  close_write bool is abstract
  exit_code u32 is abstract
  # pipe_to(T type, process_and_args array String, env_vars container.Map String String, code () -> T) outcome T is abstract



private Default_Handler(private process_id, std_in, std_out, std_err i64) ref : Handler is


  # close stdin of child process
  #
  close_write bool is
    fuzion.sys.pipe.close std_in = 0



  # write bytes to stdin of child process
  #
  public write_bytes (bytes Sequence u8) outcome i32 is
    write_bytes std_in bytes


  private write_bytes (desc i64, bytes Sequence u8) outcome i32
  pre bytes.count > 0
  is

    # how many bytes are written at a time
    # POSIX.1 requires PIPE_BUF to be at least 512 bytes
    # NYI move this to effect?
    private write_chunk_size := 512

    bytes
      .chunk write_chunk_size
      .reduce_or_error 0 ((r, t) ->
        arr := t.as_array
        bw := fuzion.sys.pipe.write desc arr.internal_array.data arr.count
        if bw = -1
          abort (outcome i32) (error "error while writing. wrote $r bytes already.")
        else
          r+bw
      )


  # read `count` bytes from standard out
  #
  read_bytes (count i32) choice (array u8) io.end_of_file error
  pre count > 0
  is
    arr := array u8 count i->0
    res := fuzion.sys.pipe.read std_out arr.internal_array.data arr.count
    if res = -1
      error "error reading from stdout."
    else if res = 0
      io.end_of_file
    else
      arr
        .slice 0 res
        .as_array


  exit_code u32 is
    close_write
    # NYI does not work yet
    # r := fuzion.sys.process.wait process_id
    fuzion.sys.pipe.close std_out
    fuzion.sys.pipe.close std_err
    # # NYI cleanup process handle
    # # fuzion.sys.process.close id
    # r
    0


  pipe_to(T type, process_and_args array String, env_vars container.Map String String, code () -> T) outcome T is

    # how many bytes are read at a time
    # POSIX.1 requires PIPE_BUF to be at least 512 bytes
    # NYI move this to effect?
    private read_chunk_size := 512

    match spawn0 process_and_args env_vars
      tup tuple =>
        (pid, std_in, std_out, std_err) := tup

        # NYI should wire pipe directly to process
        # NYI this works only when pipes buffer is large enough for
        # what is being written/read to/from pipes
        # thread to pipe from one process to other
        concur.thread.spawn ()->
          for p1rb := (read_bytes read_chunk_size), (read_bytes read_chunk_size)
          while
            match p1rb
              s array u8 => (write_bytes pipe_to.this.std_in s).ok
              * => false
          _ := fuzion.sys.pipe.close pipe_to.this.std_in

        eff := spawned (process.Default_Handler pid Default_Handler.this.std_in std_out std_err)
        t := eff
          .go code

        eff.close_write
        ec := fuzion.sys.process.wait pid
        fuzion.sys.pipe.close std_out
        fuzion.sys.pipe.close std_err
        # NYI cleanup process handle
        # fuzion.sys.process.close id

        if ec = 0
          t
        else
          error "process with id=$pid ($process_and_args, $env_vars) exited with code: $ec"

      e error => e

/*
# spawn process
#
public spawn(process_and_args array String) spawned is



# spawn process with option to pass environment variables
#
public spawn(process_and_args array String, env_vars container.Map String String) spawned is
*/


# spawn process including args
#
public spawn(T type, process_and_args array String, code () -> T) outcome T is
  spawn T process_and_args (container.ordered_map String String).type.empty code


# spawn process with option to pass environment variables
#
public spawn(T type, process_and_args array String, env_vars container.Map String String, code () -> T) outcome T is
  match spawn0 process_and_args env_vars
    tup tuple =>
      (id, std_in, std_out, std_err) := tup
      eff := (spawned (process.Default_Handler id std_in std_out std_err))
      t := eff
        .go code

      eff.close_write
      ec := fuzion.sys.process.wait id
      fuzion.sys.pipe.close std_out
      fuzion.sys.pipe.close std_err
      # NYI cleanup process handle
      # fuzion.sys.process.close id

      if ec = 0
        t
      else
        error "process with id=$id ($process_and_args, $env_vars) exited with code: $ec"

    e error => e


# spawn process with option to pass environment variables
#
private spawn0(process_and_args array String, env_vars container.Map String String) outcome (tuple i64 i64 i64 i64)
pre process_and_args.length > 0,
# NYI allow utf-8?
    process_and_args ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii)),
    spawn0.this.env_vars.keys ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii)),
    spawn0.this.env_vars.values ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii))
is

  sys := fuzion.sys
  NULL := [u8 0].internal_array.data

  # posix_spawn needs last arg to be NULL
  arg_data := array fuzion.sys.Pointer process_and_args.count+1 (i -> if i<process_and_args.length then sys.c_string process_and_args[i] else NULL)


  env_var_strings := env_vars
    .items
    .map_sequence (x ->
      (k, v) := x
      "$k=$v")
    .as_array


  env_var_c_strings := env_var_strings
    .map_sequence (x -> sys.c_string x)
    .as_array

  # posix_spawn needs last arg to be NULL
  env_data := array fuzion.sys.Pointer env_var_c_strings.count+1 (i -> if i<env_var_c_strings.count then env_var_c_strings[i] else NULL)

  res_data := array i64 4 i->0

  # args as string for windows to avoid malloc in backend
  args_str := sys.c_string (String.type.join process_and_args " ")


  # environment variables for windows to avoid malloc in backend
  # NULL terminates each environment variable
  # NULL is also used to terminate the environment variables data structure.
  env_str := sys.c_string ((String.type.join env_var_strings (codepoint 0)) + (codepoint 0))

  if (sys.process.create arg_data.internal_array.data arg_data.count env_data.internal_array.data env_data.count res_data.internal_array.data args_str env_str) = -1
    error "*** error creating process ***"
  else
    (res_data[0], res_data[1], res_data[2], res_data[3])

