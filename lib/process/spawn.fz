# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature process.spawn
#
# -----------------------------------------------------------------------

spawned =>
  process.spawned.env


# NYI move this to effect?
private spawned(h process.Handler) : simple_effect
is

  # how many bytes are read at a time
  # POSIX.1 requires PIPE_BUF to be at least 512 bytes
  # NYI move this to effect?
  private read_chunk_size := 512

  read_bytes(count i32) choice error io.end_of_file (Sequence u8) is
    h.read_bytes count
  write_bytes(bytes Sequence u8) outcome i32 is
    h.write_bytes bytes

  # read all of stdout to string
  # NYI return error on error
  #
  read_string outcome String is
    (arr, last_read) :=
      for acc := (marray (Sequence u8)).type.new 0 (Sequence u8).type.empty,
          acc.add (match res
                      s Sequence u8 => s
                      * => panic "illegal state")
          res := h.read_bytes read_chunk_size, h.read_bytes read_chunk_size
      while
        match res
          Sequence => true
          * => false
      else
        (acc, res)

    match last_read
      io.end_of_file =>
        ref : String
          utf8 Sequence u8 is
            arr.flat_map_sequence u8 (x -> x)
      e error => e
      Sequence => panic "illegal"


  # write string to stdin of child process
  #
  write_string (s String) outcome i32 is
    h.write_bytes s.utf8

  close_write =>
    h.close_write

  exit_code =>
    h.exit_code

  infix | (process_and_args array String) outcome process.spawned is
    h.pipe_to process_and_args (container.ordered_map String String).type.empty

  infix | (process_and_args array String, env_vars container.Map String String) outcome process.spawned is
    h.pipe_to process_and_args env_vars



Handler ref is
  read_bytes(count i32) choice error io.end_of_file (Sequence u8) is abstract
  write_bytes(bytes Sequence u8) outcome i32 is abstract
  close_write bool is abstract
  exit_code u32 is abstract
  pipe_to(process_and_args array String, env_vars container.Map String String) outcome spawned is abstract



private Default_Handler(private process_id, std_in, std_out, std_err i64) ref : Handler is


  # close stdin of child process
  #
  close_write bool is
    close_write std_in


  private close_write(desc i64) bool is
    fuzion.sys.pipe.close std_in = 0


  # wait for the process to end
  #
  exit_code =>
    # should we do this automatically?
    close_write
    r := fuzion.sys.process.wait process_id
    fuzion.sys.pipe.close std_out
    fuzion.sys.pipe.close std_err
    r


  # write bytes to stdin of child process
  #
  public write_bytes (bytes Sequence u8) outcome i32 is
    write_bytes std_in bytes


  private write_bytes (desc i64, bytes Sequence u8) outcome i32
  pre bytes.count > 0
  is

    # how many bytes are written at a time
    # POSIX.1 requires PIPE_BUF to be at least 512 bytes
    # NYI move this to effect?
    private write_chunk_size := 512

    bytes
      .chunk write_chunk_size
      .reduce_or_error 0 ((r, t) ->
        arr := t.as_array
        bw := fuzion.sys.pipe.write desc arr.internal_array.data arr.count
        if bw = -1
          abort (outcome i32) (error "error while writing. wrote $r bytes already.")
        else
          r+bw
      )


  # read `count` bytes from standard out
  #
  read_bytes (count i32) choice error io.end_of_file (Sequence u8)
  pre count > 0
  is
    arr := array u8 count i->0
    res := fuzion.sys.pipe.read std_out arr.internal_array.data arr.count
    if res = -1
      error "error reading from stdout."
    else if res = 0
      io.end_of_file
    else
      arr.slice 0 res




  pipe_to(process_and_args array String, env_vars container.Map String String) outcome spawned is

    # how many bytes are read at a time
    # POSIX.1 requires PIPE_BUF to be at least 512 bytes
    # NYI move this to effect?
    private read_chunk_size := 512

    match spawn process_and_args env_vars unit
      t tuple =>
        (pid, std_in, std_out, std_err) := t

        # NYI should wire pipe directly to process
        # NYI this works only when pipes buffer is large enough for
        # what is being written/read to/from pipes
        # thread to pipe from one process to other
        concur.thread.spawn ()->
          for p1rb := (read_bytes read_chunk_size), (read_bytes read_chunk_size)
          while
            match p1rb
              s Sequence u8 => (write_bytes pipe_to.this.std_in s).ok
              * => false
          _ := close_write pipe_to.this.std_in

        spawned (process.Default_Handler pid Default_Handler.this.std_in std_out std_err)
      e error => e


# spawn process - shorthand without environment variables
#
public spawn(process_and_args array String) outcome spawned is
  spawn process_and_args (container.ordered_map String String).type.empty


# spawn process with option to pass environment variables
#
public spawn(process_and_args array String, env_vars container.Map String String) outcome spawned is
  match spawn process_and_args env_vars unit
    t tuple =>
      (id, std_in, std_out, std_err) := t
      spawned (process.Default_Handler id std_in std_out std_err)
    e error => e


# spawn process with option to pass environment variables
#
private spawn(process_and_args array String, env_vars container.Map String String, _ unit) outcome (tuple i64 i64 i64 i64)
pre process_and_args.length > 0,
# NYI allow utf-8?
    process_and_args ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii)),
    spawn.this.env_vars.keys ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii)),
    spawn.this.env_vars.values ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii))
is

  sys := fuzion.sys

  # posix_spawn needs last arg to be NULL
  arg_data := array Any process_and_args.count+1 (i -> if i<process_and_args.length then sys.c_string process_and_args[i] else Any)


  env_var_strings := env_vars
    .items
    .map_sequence (x ->
      (k, v) := x
      "$k=$v")
    .as_array


  env_var_c_strings := env_var_strings
    .map_sequence (x -> sys.c_string x)
    .as_array

  # posix_spawn needs last arg to be NULL
  env_data := array Any env_var_c_strings.count+1 (i -> if i<env_var_c_strings.count then env_var_c_strings[i] else Any)

  res_data := array i64 4 i->0

  # args as string for windows to avoid malloc in backend
  args_str := sys.c_string (String.type.join process_and_args " ")


  # environment variables for windows to avoid malloc in backend
  # NULL terminates each environment variable
  # NULL is also used to terminate the environment variables data structure.
  env_str := sys.c_string ((String.type.join env_var_strings (codepoint 0)) + (codepoint 0))

  if (sys.process.create arg_data.internal_array.data arg_data.count env_data.internal_array.data env_data.count res_data.internal_array.data args_str env_str) = -1
    error "*** error creating process ***"
  else
    (res_data[0], res_data[1], res_data[2], res_data[3])

