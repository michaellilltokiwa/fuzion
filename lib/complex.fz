# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature complex
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# complex -- complex numbers based on arbitrary numeric type
#
# complex provides complex numbers based on a numeric type (e.g. f64, i32).
# A complex number consists of a real and an imaginary part.
#
complex<T : numeric<T>> (real,    # real part
                         imag T   # imaginary part
                         ) : numeric<complex<T>>, complexes<T>
is

# private:

  # just for brevity
  a => complex.this

# public:

  # enable generic features in ancestors
  redef thiz => complex.this
  redef orderedThis => complex.this

  # basic operations
  redef prefix + => a
  redef infix +  (b complex<T>) => complex a.real+b.real a.imag+b.imag
  redef infix -  (b complex<T>) => complex a.real-b.real a.imag-b.imag
  redef infix *  (b complex<T>) => complex a.real*b.real-a.imag*b.imag a.real*b.imag+a.imag*b.real
  redef infix /  (b complex<T>) complex<T>
    pre
      safety: b != zero
  is
    n := b.real*b.real+b.imag*b.imag
    complex (a.real*b.real+a.imag*b.imag)/n (a.imag*b.real-a.real*b.imag)/n

  # comparison
  redef infix == (b complex<T>) => a.real  = b.real && a.imag  = b.imag
  redef infix != (b complex<T>) => a.real != b.real || a.imag != b.imag

  # NYI: total order ignoring imag
  redef infix <  (b complex<T>) => a.real <  b.real
  redef infix <= (b complex<T>) => a.real <= b.real
  redef infix >  (b complex<T>) => a.real >  b.real
  redef infix >= (b complex<T>) => a.real >= b.real

  absÂ² => real*real+imag*imag

  redef asString =>
    si :=
      for c in ($imag).asCodepoints
      until !("0123456789.+-".contains c)
        "($imag)"
      else
        $imag
    p := if (si.startsWith "-") then "" else "+"
    "{real}$p{si}i"

  # NYI: these three should be implemented in complexes, not here:
  redef zero => complex real.zero real.zero
  redef one  => complex real.one real.zero
  i => complex real.zero real.one
